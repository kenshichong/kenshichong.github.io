<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Dung Beetle]]></title>
  <subtitle><![CDATA[Be a machine]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://kenshichong.github.io/"/>
  <updated>2016-05-12T02:16:45.066Z</updated>
  <id>http://kenshichong.github.io/</id>
  
  <author>
    <name><![CDATA[kenshichong]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[写着玩-系统调用与API]]></title>
    <link href="http://kenshichong.github.io/2016/05/11/%E5%86%99%E7%9D%80%E7%8E%A9-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8EAPI/"/>
    <id>http://kenshichong.github.io/2016/05/11/写着玩-系统调用与API/</id>
    <published>2016-05-11T12:09:25.000Z</published>
    <updated>2016-05-12T02:16:45.066Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>这本书快完了，加快效率。。。</p>
<h1 id="0x01_系统调用">0x01 系统调用</h1><p>由于系统有限的资源有可能被多个不同的应用程序同时访问，因此，如果不加以保护，那么各个应用程序难免产生冲突。现代OS采取的策略是将这些可能产生冲突的系统资源给保护起来，然后给我们提供相应的接口去让我们按照OS所能接受的范围去操纵这些资源，这些接口就是所谓的系统调用。系统调用是较底层的接口，我们所写的用户层的程序以及运行库这种，它的一些函数都是对系统调用的封装。当然，我们可以直接使用系统调用</p>
<p>系统调用往往通过中断来实现，比如linux使用0x80号中断作为系统调用的入口，windows采用0x2e号中断作为系统调用入口。</p>
<p>对于windows来讲，系统调用实际上不是它与应用程序的最终接口，而是API，我们暂可以把API与系统调用等同起来，API的数量从最初的450个增加到了现在的数千个。</p>
<p>对于linux来说，系统调用由0x80中断完成，各个通用寄存器用于传递参数(如我们熟悉的用EAX传递功能号)我们完全可以绕过glibc的fopen、fread、fclose(这些函数也是封装的系统调用)打开读取和关闭文件，而直接使用open()、read()和close()来实现文件的读取，就不举例了。</p>
<p>我们可以使用linux的man命令查看每个系统调用的详细说明，比如查看read(参数2表示系统调用手册)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man <span class="number">2</span> <span class="built_in">read</span></span><br></pre></td></tr></table></figure></p>
<h2 id="系统调用的弊端">系统调用的弊端</h2><p>不到万不得已，不要直接用系统调用写程序，使用不便和不跨平台(不兼容)</p>
<p><img src="/img/写着玩-系统调用与API/0.PNG" alt=""></p>
<p>运行库已经帮助我们把系统调用给封装好了，C语言的标准库是跨平台的，就是说他会把平台的差异(即使系统调用符号、实现不同)给屏蔽掉，提供给我们统一的接口，这个接口是统一的功能：</p>
<p><img src="/img/写着玩-系统调用与API/1.PNG" alt=""></p>
<p>感谢写C标准库的人，使他们使我们的编程变得简单。但是为了保证跨平台性，它只能取所有的平台，所有的OS都支持的功能</p>
<p><img src="/img/写着玩-系统调用与API/2.PNG" alt=""></p>
<p>关于中断的详细分析，可以去看我写的两篇OS相关的，这里就不啰嗦了。</p>
<h2 id="linux的新型系统调用机制">linux的新型系统调用机制</h2><p><img src="/img/写着玩-系统调用与API/3.PNG" alt=""><br><img src="/img/写着玩-系统调用与API/4.PNG" alt=""><br><img src="/img/写着玩-系统调用与API/5.PNG" alt=""><br><img src="/img/写着玩-系统调用与API/6.PNG" alt=""></p>
<h2 id="关于dd命令">关于dd命令</h2><p><img src="/img/写着玩-系统调用与API/7.PNG" alt=""></p>
<p>也就是说想要dump内存的话，可以通过dd命令，借助/proc/pid/mem的内存快照来达到dump pid对应进程的任意地址处的内存内容</p>
<h1 id="0x02_Windows_API">0x02 Windows API</h1><p><strong>没有什么是加层解决不了的，如果有，就再来一层</strong><br>Windows API 是指Windows操作系统提供给应用程序开发者的最底层的、最直接与Windows打交道的接口。Windows操作系统下，CRT是建立在Windows API之上的，另外还有很多对Windows API的各种包装库，MFC就是很著名的一种以C++形式封装的库。</p>
<p><img src="/img/写着玩-系统调用与API/8.PNG" alt=""><br><img src="/img/写着玩-系统调用与API/9.PNG" alt=""></p>
<p>其中有一个头文件”Windows.h”包含了Windows API的核心部分，只要我们在程序里面包含了它，就可以使用Windows API的核心部分了。</p>
<p><img src="/img/写着玩-系统调用与API/10.PNG" alt=""><br><img src="/img/写着玩-系统调用与API/11.PNG" alt=""></p>
<p>模块相当于在API的基础上又封装了一层，从而提供更加集成化的功能。</p>
<p>API的核心就是：<br><strong> 不管内核如何改变接口，只要维持API层面的接口不变，理论上所有的应用程序都不用重新编译就可以正常运行，这也是Windows API存在的主要原因，解决兼容性的问题就交给具体的API实现了，我们只需要最后的API接口，我们只需要知道这个接口可以达到什么样的目的就ok了。 </strong></p>
<h1 id="0xFF_最终结">0xFF 最终结</h1><p>此书的最后一章主要讲解了如何去实现一个自己的迷你运行库(miniCRT)，以及在最初的架构上如何对其进行扩展，对此没什么兴趣，所以就不谈这一章了。</p>
<p>后面还有一些手册类的东西，比如ELF文件结构中的常见段的一个简要功能介绍，GCC(编译器)命令行参数参考、ld(GNU链接器)命令行参数参考、objdump(GNU目标文件可执行文件查看器)命令行参数参考、cl(MSVC编译器)命令行参数参考、link(MSVC链接器)命令行参数参考、dumpbin(MSVC的COFF/PE文件查看器)</p>
<p>到这，程序员的修养大法这本书就算做完笔记了，也算是给了自己一个交代。</p>
<p>挺不错的一本书，讲了很多理论干货，也算是自己读的比较认真的一本书了。</p>
<p>接下来会去读其他的书，毕竟书是有体系的，跟着书学也能够让自己沉下心来，光看帖子，浏览网站学习容易浮躁，果然还是要打牢理论基础。</p>
<p>接下来的计划就是读C++反汇编与逆向分析这本书，挑战是在最短的时间内干完此书，继续人丑就该多读书系列。</p>
<p>就酱。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>这本书快完了，加快效率。。。</p>
<h1 id="0x01_系统调用">0x01 系统调用</h1><p>由于系统有限的资源有可能被多个不同的应用程序同时访问，因此，如果不加以保护，那么各个应用程序难免产生冲突。]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-运行库]]></title>
    <link href="http://kenshichong.github.io/2016/05/09/%E5%86%99%E7%9D%80%E7%8E%A9-%E8%BF%90%E8%A1%8C%E5%BA%93/"/>
    <id>http://kenshichong.github.io/2016/05/09/写着玩-运行库/</id>
    <published>2016-05-09T00:38:03.000Z</published>
    <updated>2016-05-11T03:28:56.241Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>继续坚持。。。</p>
<h1 id="0x01_入口函数和程序初始化">0x01 入口函数和程序初始化</h1><p>不管是在程序的开始还是程序的结束，main既不是最初被调用的，也不是最后被调用的，在main之前或之后，还可以有很多事情我们可以做，我们可以插入我们想要执行的代码。</p>
<p>操作系统在创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数。</p>
<p>举个例子：</p>
<p><img src="/img/写着玩-运行库/0.PNG" alt=""></p>
<h2 id="GLIBC入口函数">GLIBC入口函数</h2><p>glibc的启动过程在不同的情况下差别很大，比如静态的glibc和动态的glibc的差别，glibc用于可执行文件和用于共享库的差别，可以组合4种情况。下面关于Glibc和MSVCCRT的相关代码分析在不额外说明的情况下，都默认为静态/可执行文件链接的情况。其他情况自行举一反三</p>
<p><img src="/img/写着玩-运行库/1.PNG" alt=""></p>
<p>在介绍这段代码之前，我们首先要知道栈的布局是什么样的。</p>
<p>在前面我们介绍过，进程刚开始启动的时候，须知道一些进程运行的环境，最基本的就是系统环境变量和进程的运行参数。这些信息是需要在进程启动之前就需要提前给进程准备好的，一种常见的做法就是操作系统在进程启动前将这些信息提前保存到进程的虚拟空间的栈中(也就是VMA中的Stack VMA)。</p>
<p><img src="/img/写着玩-运行库/2.PNG" alt=""><br><img src="/img/写着玩-运行库/3.PNG" alt=""><br><img src="/img/写着玩-运行库/4.PNG" alt=""></p>
<p>这里我们谈运行库，也就是说在glibc的start执行之前的栈结构就已经被初始化成了这个样子。</p>
<p>接下来看start：</p>
<p><img src="/img/写着玩-运行库/5.PNG" alt=""><br><img src="/img/写着玩-运行库/6.PNG" alt=""></p>
<p>环境变量：</p>
<p><img src="/img/写着玩-运行库/7.PNG" alt=""></p>
<p>start后时__libc_start_main:</p>
<p><img src="/img/写着玩-运行库/8.PNG" alt=""><br><img src="/img/写着玩-运行库/9.PNG" alt=""></p>
<p>对于<strong>libc_start_main中的</strong>BOUNDED_POINTERS__宏定义的说明：</p>
<p><img src="/img/写着玩-运行库/10.PNG" alt=""></p>
<p>接着看：</p>
<p><img src="/img/写着玩-运行库/11.PNG" alt=""><br><img src="/img/写着玩-运行库/12.PNG" alt=""><br><img src="/img/写着玩-运行库/13.PNG" alt=""><br><img src="/img/写着玩-运行库/14.PNG" alt=""></p>
<p>对于hlt指令的说明：</p>
<p><img src="/img/写着玩-运行库/15.PNG" alt=""></p>
<p>总结下，就是start开始，传入7个参数调用<strong>libc_start_main，在</strong>libc_start_main中，对各个参数进行解析，并将参数赋予一些具有具体意义的变量，以便后面使用；然后是调用一系列函数，在这些函数中，其中一个就是将main之后需要调用的函数提前注册一下，然后就是main了，main之后，调用exit，在exit中，会遍历链表，将上面注册的需要在面之后调用的函数调用，然后调用_exit()，_exit()中就是exit的系统调用，然后正常退出。</p>
<h2 id="MSVC_CRT入口函数">MSVC CRT入口函数</h2><p>MSVC的CRT默认的入口函数名为mainCRTStartup:</p>
<p><img src="/img/写着玩-运行库/16.PNG" alt=""><br><img src="/img/写着玩-运行库/17.PNG" alt=""></p>
<p>对于alloca的说明：<br><img src="/img/写着玩-运行库/20.PNG" alt=""></p>
<p>接着说：<br><img src="/img/写着玩-运行库/18.PNG" alt=""><br><img src="/img/写着玩-运行库/19.PNG" alt=""></p>
<p>总结下，这个mainCRTStartup的总体流程就是：</p>
<ol>
<li>初始化和OS版本有关的全局变量</li>
<li>初始化堆</li>
<li>初始化I/O</li>
<li>获取命令行参数和环境变量</li>
<li>初始化C库的一些数据</li>
<li>调用main并记录返回值</li>
<li>检查错误并将main的返回值返回</li>
</ol>
<h1 id="0x02_运行库与I/O">0x02 运行库与I/O</h1><p>一个程序的I/O指代了程序与外界的交互，包括文件、管道、网络、命令行、信号等。更广义地讲，I/O指代任何操作系统理解为“文件”的事务。在操作系统层面上，文件操作也有类似于FILE的一个概念，在linux里，这叫做文件描述符(fd)，而在Windows里，叫做句柄(handle)</p>
<p><img src="/img/写着玩-运行库/21.PNG" alt=""></p>
<p>给出FILE、fd、打开文件表和打开文件对象的关系图：<br><img src="/img/写着玩-运行库/22.PNG" alt=""></p>
<p>图中，内核指针p指向该进程的打开文件表，所以只要有fd，就可以用fd+p来得到打开文件表的某一项地址。stdin、stdout、stderr均是FILE结构的指针。</p>
<p>对于Windows的句柄，与linux的fd大同小异，不过Windows的句柄并不是打开文件表的下标，而是其下标经过某种线性变换之后的结果(如果变换是线性的话，可以通过多打开几个文件，来求解这种线性转换关系)。</p>
<p>所谓的I/O初始化，指I/O初始化函数需要在用户空间中建立stdin、stdout、stderr及其对应的FILE结构，使得程序进入main之后就可以直接使用printf、scanf等函数。</p>
<p>前面我们提到了MSVC CRT的入口函数，其中涉及到初始化部分。</p>
<p><strong>对于堆的初始化：</strong></p>
<p><img src="/img/写着玩-运行库/23.PNG" alt=""></p>
<p>可以看出，MSVC的堆初始化过程异常简单，仅仅调用了HeapCreate这个函数创建了一个系统堆。因此不难推测，MSVC的malloc函数必然调用HeapAlloc这个API，将堆管理的过程直接交给了操作系统。</p>
<p><strong>对于I/O初始化：</strong><br>我们先从总体上把握下I/O的初始化，MSVC的I/O初始化主要进行了如下几个工作：</p>
<ol>
<li>建立打开文件表。</li>
<li>如果能够继承自父进程，那么从父进程获取继承的句柄。</li>
<li>初始化标准输入输出。</li>
</ol>
<p>下面一个个来解释：<br>首先，每个进程都有一个自己的打开文件表，I/O初始化就是对这个打开文件表的初始化。</p>
<p><img src="/img/写着玩-运行库/24.PNG" alt=""></p>
<p>在初始化开始部分，会先声明一个数组，对应于图中的ioinfo * __pioinfo[64]，这是一个指针数组，共有64个ioinfo结构的指针，这64个指针又分别指向ioinfo数组，书中说，每个数组的大小是32个ioinfo结构，所以这相当于一个二维数组。这里使用指针数组的原因是指针数组可以根据需要来去动态的申请空间，而不像二维数组那样，一上来就搞了64x32的大小，浪费。</p>
<p>这个指针数组毫无疑问就是打开文件表了，它的成员是ioinfo结构，给出这个结构体的定义：</p>
<p><img src="/img/写着玩-运行库/25.PNG" alt=""><br><img src="/img/写着玩-运行库/26.PNG" alt=""></p>
<p>MSVC的I/O初始化就是要构造这个二维的打开文件表。构造过程是在I/O初始化函数_ioinit中，该函数定义于crt/src/ioinit.c中。</p>
<p>首先，_ioinit函数初始化了__pioinfo数组的第一个二级数组：</p>
<p><img src="/img/写着玩-运行库/27.PNG" alt=""></p>
<p>在这里_ioinit初始化了的__pioinfo[0]里的每一个元素为无效值，只起到一个占位的作用，其中INVALID_HANDLE_VALUE是Windows句柄的无效值，值为-1.</p>
<p>接下来，_ioinit的工作就是将一些预定义的打开文件给初始化，这包括两部分：</p>
<p><img src="/img/写着玩-运行库/28.PNG" alt=""></p>
<p>上图中说到，对于打开文件表的初始化，如果有继承自父进程的打开文件句柄，则需要把继承的句柄给填到自己的打开文件表中。如何获得从父进程继承的打开文件句柄呢？</p>
<p>可以使用API GetStartupInfo来获取继承的打开文件，GetStartInfo的参数如下：</p>
<p><img src="/img/写着玩-运行库/29.PNG" alt=""><br><img src="/img/写着玩-运行库/30.PNG" alt=""></p>
<p>有了GetStartupInfo结构以后，再根据上面的介绍，我们就可以得到继承的句柄了。而_ioinit函数也正是这么做的：</p>
<p><img src="/img/写着玩-运行库/31.PNG" alt=""></p>
<p>有了继承的句柄，下面就要往自己的打开文件表里填充了。</p>
<p>在填充之前，先是判断了一下直接的打开的文件表是否足以容纳所有的句柄：</p>
<p><img src="/img/写着玩-运行库/32.PNG" alt=""></p>
<p>然后要给打开文件表分配足够的空间以容纳所有的句柄：</p>
<p><img src="/img/写着玩-运行库/33.PNG" alt=""></p>
<p>可以看出，新分配的都是填入的无效数据，起到占位的作用。分配过后，填充就很容易了。</p>
<p><img src="/img/写着玩-运行库/34.PNG" alt=""><br><img src="/img/写着玩-运行库/35.PNG" alt=""><br><img src="/img/写着玩-运行库/36.PNG" alt=""></p>
<p>到这，I/O初始化算是真正完成了，所有的I/O函数都可以自由使用了。</p>
<p>我们知道，我们进行I/O操作时，都是把我们要进行I/O操作的对象当做文件来处理的，借由一系列的文件函数来达到I/O的效果。文件函数操作的是一种被称作FILE的结构。我们来看FILE结构和I/O的关系：</p>
<p>给出FILE结构定义：</p>
<p><img src="/img/写着玩-运行库/37.PNG" alt=""></p>
<p>图中说到通过_file字段可以访问到内部文件句柄表中的对应项，而通过前面的介绍，我们知道句柄值存储在ioinfo的osfhnd字段中且只有拿到句柄才能对相应的文件对象进行操作。</p>
<p>假设现在我们通过fopen()函数得到了一个FILE结构的指针，我们看下如何系统是如何通过这个FILE结构找到相应的句柄并进行文件操作的：</p>
<p>我们知道，句柄值(osfhnd)所在的ioinfo结构是处在__pioinfo这个二维数组中的，FILE结构中的_file的值，和此表的两个下标直接相关联。</p>
<p><img src="/img/写着玩-运行库/38.PNG" alt=""></p>
<p>这样，我们就知道FILE和句柄的对应关系了，有了句柄就可以进行操作了。</p>
<p>入口函数最重要的两部分-堆初始化和I/O初始化已经在上面谈到了。但是，入口函数只是冰山一角，它隶属的是一个庞大的代码集合，这个代码集合叫做运行库。</p>
<h1 id="0x03_C语言运行库">0x03 C语言运行库</h1><p>C程序的运行，都需要C运行库(CRT)的支持。C语言运行库是一个庞大的代码集合，不管是VS中的VC/srt/src还是linux下的libc，都是大的要命，啃不动。</p>
<p>一个C语言运行库大致包含了如下功能：</p>
<ol>
<li>启动与退出：包括入口函数及入口函数所依赖的其他函数等</li>
<li>标准函数：由C语言标准规定的C语言标准库所拥有的函数实现</li>
<li>I/O：I/O功能的封装和实现</li>
<li>堆：堆的封装和实现</li>
<li>语言实现：语言中一些特殊功能的实现</li>
<li>调试：实现调试功能的代码</li>
</ol>
<p>运行库的组成成分中，C语言标准库占据了主要地位。C语言标准库是C语言标准化的基础函数库，我们平时使用的printf、exit等都是标准库的一部分。标准库中定义了C语言中普遍存在的函数集合，我们可以放心的使用标准库中规定的函数而不用担心在将代码移植到别的平台时对应的平台上不提供这个函数。也就是说，只要支持C语言(常见的OS都是支持C的，很多都是C写的)，那么这些函数就可以正常运行。</p>
<p>ANSI C的标准库由24个C头文件组成，与许多其他语言(如java)的标准库不同，C语言的标准库非常轻量，仅仅包含数学函数、字符/字符串处理，I/O等基本方面。</p>
<p><img src="/img/写着玩-运行库/39.PNG" alt=""><br><img src="/img/写着玩-运行库/40.PNG" alt=""></p>
<p>基本的就不介绍了，下面介绍下上面提到的变长参数和非局部跳转：</p>
<h2 id="变长参数">变长参数</h2><p>变长参数的一个典型例子就是printf()，那么标准库中，在这种允许变长参数的函数内部是怎样去访问这些变长参数的呢？是使用几个宏-va_list、va_start()、va_arg():</p>
<p><img src="/img/写着玩-运行库/41.PNG" alt=""></p>
<p>变长参数的实现原理：<br>支持变长参数的C标准库函数一般调用方式都是cdecl的，变长参数的实现得益于C语言默认的cdecl调用惯例的自右向左压栈传递方式。</p>
<p>其实我们完全可以自己实现变长参数的支持，举个例子：<br>设想如下函数：</p>
<p>int sum(unsigned num,…);</p>
<p><img src="/img/写着玩-运行库/42.PNG" alt=""></p>
<p>这里，需要注意：</p>
<p><img src="/img/写着玩-运行库/43.PNG" alt=""></p>
<p>对于printf狂乱输出的问题，了解printf的，应该都知道用不好printf所带来的危险性。</p>
<p>回到前面说的va_list等宏的实现问题上，理所当然的很简单：</p>
<p><img src="/img/写着玩-运行库/44.PNG" alt=""></p>
<p>小扩展：变长参数宏的实现：</p>
<p><img src="/img/写着玩-运行库/45.PNG" alt=""><br><img src="/img/写着玩-运行库/46.PNG" alt=""></p>
<h2 id="非局部跳转">非局部跳转</h2><p>这绝对是黑科技！！！</p>
<p><img src="/img/写着玩-运行库/47.PNG" alt=""></p>
<p>C语言运行库从某种程度上来讲是C语言的程序和不同操作系统平台之间的抽象层，它将不同的操作系统API抽象成相同的库函数。比如我们可以在不同的操作系统平台下使用fread来读取文件，而事实上fread在不同的操作系统平台下的实现是不同的，但作为运行库的使用者我们不需要关心这一点。</p>
<p>linux和Windows平台下的两个主要C语言运行库分别为glibc(GNU C Library)和 MSVCRT(Microsoft Visual C Run-time).</p>
<p><img src="/img/写着玩-运行库/48.PNG" alt=""></p>
<h2 id="glibc">glibc</h2><p>glibc的历史就不说了，没jb意思。事实上glibc出了C标准库之外，还有几个辅助程序运行的运行库，这几个文件可以称得上是真正的”运行库”，他们是/usr/lib/crt1.o、/usr/lib/crti.o、/usr/lib/crtn.o</p>
<h2 id="glibc启动文件">glibc启动文件</h2><p>crt1.o里面包含的就是程序的入口函数_start。</p>
<p>对于crti.o和crtn.o，这两个目标文件中包含的代码实际上是_init()函数和_finit()函数的开始和结尾部分，当这两个文件和其他目标文件顺序链接起来以后，刚好形成两个完整的函数_init()和_finit()。给出这两个文件的反汇编代码：</p>
<p><img src="/img/写着玩-运行库/49.PNG" alt=""><br><img src="/img/写着玩-运行库/50.PNG" alt=""><br><img src="/img/写着玩-运行库/51.PNG" alt=""></p>
<p>我们在前面提到过，crt1.o包含_start，在_start中，会调用<strong>libc_start_main()，在调用时，它向该函数传递了两个函数指针”</strong>libc_csu_init”和”__libc_csu_fini”，这两个函数负责调用_init()和_finit()，主要用于在main()函数之前执行的全局/静态对象构造和必须在main()函数之后执行的全局/静态对象析构。</p>
<p><img src="/img/写着玩-运行库/52.PNG" alt=""></p>
<h2 id="取消默认的启动文件和C语言运行库">取消默认的启动文件和C语言运行库</h2><p><img src="/img/写着玩-运行库/53.PNG" alt=""></p>
<h2 id="GCC平台相关目标文件">GCC平台相关目标文件</h2><p><img src="/img/写着玩-运行库/54.PNG" alt=""></p>
<h2 id="MSVC_CRT">MSVC CRT</h2><p>书上只是介绍了运行库的版本问题，以及如何通过命名方法来识别某个库支持什么。</p>
<p><img src="/img/写着玩-运行库/55.PNG" alt=""></p>
<p>上图中所列的都是C语言的标准库，MSVC还提供了相应的C++标准库</p>
<p><img src="/img/写着玩-运行库/56.PNG" alt=""></p>
<p>如果程序是用C++编写的，那么就需要额外链接相应的C++标准库，这里额外的有意思是，上图中的C++标准库里面包含的仅仅是C++的内容。当你在程序里包含了某个C++标准库的头文件时，MSVC编译器就认为该源代码文件是一个C++源代码程序</p>
<p>关于MSVC CRT的介绍，总之就是版本很多很复杂，用的时候要小心，其他就没有什么有营养的东西。</p>
<p><img src="/img/写着玩-运行库/57.PNG" alt=""></p>
<h2 id="运行库与多线程">运行库与多线程</h2><p>上面也说了，CRT是有单线程和多线程之分的，现有版本的C/C++标准是不支持多线程的，但主流的CRT都是有相应的多线程的功能的。</p>
<p>C语言运行库必须支持多线程环境。我们知道由于线程的切换和线程对于进程内存的所有数据都有访问权限的特性，就会由于在线程切换时由于访问进程内的同一资源而出现很多想不到的错误。由于多线程的普及，CRT为了支持多线程，解决这些错误，也是做了一些改进，包括使用TLS(线程局部存储)、加锁、改进函数调用方式。这些改进的核心原理就是在线程切换时，我们想要保护的线程共享数据是受到保护的。</p>
<h2 id="TLS实现">TLS实现</h2><p><img src="/img/写着玩-运行库/58.PNG" alt=""><br><img src="/img/写着玩-运行库/59.PNG" alt=""><br><img src="/img/写着玩-运行库/60.PNG" alt=""><br><img src="/img/写着玩-运行库/61.PNG" alt=""><br><img src="/img/写着玩-运行库/62.PNG" alt=""><br><img src="/img/写着玩-运行库/63.PNG" alt=""><br><img src="/img/写着玩-运行库/64.PNG" alt=""><br><img src="/img/写着玩-运行库/65.PNG" alt=""><br><img src="/img/写着玩-运行库/66.PNG" alt=""><br><img src="/img/写着玩-运行库/67.PNG" alt=""></p>
<h1 id="0x04_C++全局构造和析构">0x04 C++全局构造和析构</h1><h2 id="glibc全局构造和析构">glibc全局构造和析构</h2><p>我们在前面介绍start的时候，对于他的7个参数只是简单的列举了下，并没有详细介绍，这里详细介绍下。</p>
<p>_start-&gt;<strong>libc_start_main，_start在调用</strong>libc_start_main的时候是传递了7个参数的，其中传递的init函数指针指向的是__libc_csu_init函数，位于Glibc源代码目录的csu/ELF-init.c，给出：</p>
<p><img src="/img/写着玩-运行库/68.PNG" alt=""></p>
<p>可以看出，调用了_init()函数，前面我们谈到过crti.o的_init()函数，这里__libc_csu_init里面调用的正是”.init”段，也就是说”.init”段中的代码就将在这里被执行。我们随意反汇编一个可执行文件的.init段：</p>
<p><img src="/img/写着玩-运行库/69.PNG" alt=""><br><img src="/img/写着玩-运行库/70.PNG" alt=""></p>
<p>上面这段代码首先将<strong>CTOR_LIST</strong>数组的第一个元素当做数组元素的个数，然后将第一个元素之后的元素都当做是函数指针，并一一调用。很明显，<strong>CTOR_LIST</strong>里面存放的就是所有全局对象的构造函数的指针，那么接下来就开始研究<strong>CTOR_LIST</strong>这个数组了。</p>
<p>为了研究这个数组，我们给出一个示例代码：</p>
<p><img src="/img/写着玩-运行库/71.PNG" alt=""></p>
<p>对于每个编译单元(.cpp)，GCC编译器会遍历其中所有的全局对象，生成一个名为_GLOBAL__I_Hw的函数，由这个函数负责本编译单元的所有的全局/静态对象的构造和析构，它的代码可以表示为：</p>
<p><img src="/img/写着玩-运行库/72.PNG" alt=""></p>
<p>先不管<strong>tcf_1这个函数。对于每个编译单元，如果它有全局/静态对象，那么他会生成GLOBAL</strong>I_Hw这样的函数，然后他会在这个编译单元产生的目标文件(.o)的”.ctors”段里放置一个指针，这个指针就指向这个函数。</p>
<p>链接器在链接这些目标文件时，会将同名的段合并在一起，那么，理所当然的，每个目标文件的.ctors段将会被合并为一个.ctors段，其中的内容是各个目标文件的.ctors段的内存拼接而成。由于每个目标文件的.cors段都只存储了一个指针，指向那个用于构造和析构的函数，那么拼起来的.ctors段就是一个函数指针数组。</p>
<p>但是这个地址的数组现在是不可知的，这个数组的地址只有在链接(静态链接)的时候才能够真正确定下来，链接器是知道这个地址的，那么链接器是如何把它知道的这个关键地址告诉程序的呢？很简单，将这个地址存到某个地方不就行了，程序需要用到的时候就去这个地方取就行了。思想就是这么个思想，我们来看具体实现。</p>
<p>还记得在链接的时候，各个用户产生的目标文件的前后分别还要链接上一个crtbegin.o和crtend.o吗？这两个glibc自身的目标文件同样具有.ctors    段，在链接的时候，这两个文件的.ctors段的内容也会被合并到最终的可执行文件中。</p>
<p><img src="/img/写着玩-运行库/73.PNG" alt=""></p>
<p>解释下上图，链接器会将crtbegin.o中的.ctors段的起始地址定义成符号<strong>CTOR_LIST</strong>，这个符号是在最终链接形成的目标文件的符号段中是可以找到的，所以访问<strong>CTOR_LIST</strong>这个变量就可以得到这个数组的地址了。由于crtbegin.o中的.ctors位置的特殊性(总是第一个被合并)，因此其起始地址就是所有.ctor段最终合并后的起始地址了。</p>
<p><img src="/img/写着玩-运行库/74.PNG" alt=""></p>
<p>总结下，全局构造的实现，首先是在链接过程中，合并.ctors段得到最终的可执行文件中的.ctors段(就是一个全局构造函数指针数组)，然后将这个指针数组的起始地址记录在变量(符号)<strong>CTOR_LIST</strong>中，链接完成，得到可执行文件。可执行文件执行，按照_start -&gt; <strong>libc_start_main -&gt; </strong>libc_csu_init -&gt; _init -&gt; <strong>do_global_ctors_aux的执行顺序来执行上述函数，而在</strong>do_global_ctors_aux函数中，直接访问变量(符号)<strong>CTOR_LIST</strong>来得到全局构造函数指针，从而一个个执行构造函数，完成全局构造。</p>
<p><strong>在main前调用函数</strong><br>知道的main前调用有:</p>
<ol>
<li>TLS回调</li>
<li>.init段添加代码</li>
<li>.ctors段添加函数指针</li>
</ol>
<p><img src="/img/写着玩-运行库/75.PNG" alt=""></p>
<h2 id="析构">析构</h2><p>讲完了构造，析构已经很显然了，无非就是在main执行后采用完全相反的顺序来执行析构了，早期的glibc和GCC确实是这样做的：</p>
<p><img src="/img/写着玩-运行库/76.PNG" alt=""><br><img src="/img/写着玩-运行库/77.PNG" alt=""></p>
<p>现在采用的做法是类似的，编译的时候每个编译单元的全局/静态对象会生成一个函数，这个函数有两个作用，一是执行构造函数，而是用at_exit把其相应的析构函数给注册一下，我们知道at_exit注册的函数会在main执行后的exit中被调用，而且满足先注册后调用的机制，所以很自然的被用于析构的实现。</p>
<p><img src="/img/写着玩-运行库/78.PNG" alt=""><br><img src="/img/写着玩-运行库/79.PNG" alt=""></p>
<h2 id="MSVC_CRT的全局构造和析构">MSVC CRT的全局构造和析构</h2><p><img src="/img/写着玩-运行库/80.PNG" alt=""><br><img src="/img/写着玩-运行库/81.PNG" alt=""><br><img src="/img/写着玩-运行库/82.PNG" alt=""><br><img src="/img/写着玩-运行库/83.PNG" alt=""></p>
<p>总结下，MSVC CRT的全局构造的大体实现机制与Glibc相似，在MSVC CRT中，在形成可执行文件时，两个全局变量<strong>xc_a和</strong>xc_z就被链接器初始化为数组的起始和结束地址，然后执行时，mainCRTStartup -&gt; _inittern，在_inittern中，被循环遍历，执行全局构造。</p>
<p><strong>在MSVC中同样可以修改段来得到main之前执行的权限</strong></p>
<p><img src="/img/写着玩-运行库/84.PNG" alt=""></p>
<h2 id="MSVC_CRT析构">MSVC CRT析构</h2><p>与glibc几乎相同：</p>
<p><img src="/img/写着玩-运行库/85.PNG" alt=""><br><img src="/img/写着玩-运行库/86.PNG" alt=""></p>
<h1 id="0x05_fread实现">0x05 fread实现</h1><p>通过解析fread，进一步深入I/O</p>
<p>给出fread的函数声明：</p>
<p><img src="/img/写着玩-运行库/87.PNG" alt=""></p>
<p>我们知道，fread最终是通过Windows的系统API-ReadFile来实现对文件的读取的。给出ReadFile的函数声明：</p>
<p><img src="/img/写着玩-运行库/88.PNG" alt=""></p>
<p>可以看出他们在功能上看似完全相同，而且参数几乎一一对应。</p>
<p>我们来看fread到ReadFile的中间到底干了什么。</p>
<p>对于glibc，fread的实现过于复杂，因此这里选择MSVC的fread实现。</p>
<h2 id="缓冲">缓冲</h2><p>提到文件操作，就不得不介绍缓冲，它是一种机制：</p>
<p><img src="/img/写着玩-运行库/89.PNG" alt=""></p>
<p>由于真正去操作文件是一件对OS来说非常费劲的事，所以要使用缓冲。当要读取数据的时候，首先看看这个文件的缓冲里有没有数据，如果有数据就直接从缓冲中取。如果缓冲是空的，那么CRT就通过操作系统一次性读取文件一块较大的内容填充缓冲，这样，如果每次读取文件都是一些尺寸很小的数据，那么这些读取操作大多都直接从缓冲中获得，可以避免大量的实际文件访问。</p>
<p>C语言标准库提供了几个与缓冲相关的基本函数，都是熟人：</p>
<p><img src="/img/写着玩-运行库/90.PNG" alt=""></p>
<h2 id="fread_s">fread_s</h2><p>fread定义在crt/fread.c中，实际内容只有一行：</p>
<p><img src="/img/写着玩-运行库/91.PNG" alt=""><br><img src="/img/写着玩-运行库/92.PNG" alt=""><br><img src="/img/写着玩-运行库/93.PNG" alt=""><br><img src="/img/写着玩-运行库/94.PNG" alt=""><br><img src="/img/写着玩-运行库/95.PNG" alt=""><br><img src="/img/写着玩-运行库/96.PNG" alt=""></p>
<p>可以看出，文件的缓冲是在FILE结构中指出的，有缓冲的话，就会直接从文件缓冲中进行read，这里要把文件缓冲和buf分开。</p>
<p><img src="/img/写着玩-运行库/97.PNG" alt=""></p>
<p>是否使用文件缓冲以及使用文件缓冲的类型是在flag字段中记录的，下面的anybuf宏check是否使用文件缓冲也是根据flag中的这三个标志位来check的。</p>
<p><img src="/img/写着玩-运行库/98.PNG" alt=""></p>
<p>到这里，仅仅是确定了是否有文件缓冲，然后准备读数据，但此时还没有读，这里要分清两个读的过程，即从文件缓冲中读，读到最终的目的地buffer中和从真正的文件中读，读到文件缓冲中。此时，这两个读都没有发生，具体怎样读，分三种情况：</p>
<ol>
<li><p><img src="/img/写着玩-运行库/99.PNG" alt=""><br><img src="/img/写着玩-运行库/100.PNG" alt=""></p>
</li>
</ol>
<p>什么意思呢，就是有文件缓冲，并且缓冲不为空，就是说缓冲中有数据，则直接从文件缓冲中读数据读到最终目的地buffer中。</p>
<p>其中，nbytes代表这次要从文件缓冲中读取多少字节，在这里，nbytes等于还需要读取的字节数(count)与缓冲中剩余数据的字节数(stream -&gt; _cnt)中较小的一个。接下来的一行使用memcpy_s将文件缓冲里ptr所指向的缓冲内容复制到data指向的最终目的地buffer中。接下来的5行就是更新FILE结构和局部变量由于这次操作而改变后的数据。</p>
<p><img src="/img/写着玩-运行库/101.PNG" alt=""></p>
<ol>
<li>上面的1是缓冲不为空时的操作，当缓冲为空时(缓冲为空有两种可能，第一种是缓冲不为空，但读的数据大于缓冲的大小，直接通过1之后把缓冲读空了；第二种情况是虽然有缓冲，但缓冲本来就是空的)，又分为两种情况：</li>
</ol>
<p><img src="/img/写着玩-运行库/102.PNG" alt=""></p>
<p>对于情况1：</p>
<p><img src="/img/写着玩-运行库/103.PNG" alt=""></p>
<p>从文件中读整数个文件缓冲大小的数据(向上取整，在上面也可以看到这个读取的过程是一个while的循环过程，直到count(count是我们给定的我们想要从文件中读取的数据的大小)为0退出循环)，也就是说这种情况下，每次都会读取文件缓冲大小的数据，而且不经过缓冲，直接从文件中读数据，然后把数据填到最终目的地buffer中，直到剩余的count的大小小于文件缓冲的尺寸，然后会执行情况2的代码：</p>
<p>对于情况2，即要读取的数据不大于缓冲的尺寸，那么仅需要重新填充缓冲即可：</p>
<p><img src="/img/写着玩-运行库/104.PNG" alt=""></p>
<p>反正到最后缓冲剩余的数据大小是&gt;=0的。</p>
<p>可以看出。不管是哪种情况，只要是从文件中读数据，都是使用的同一个函数，那就是_read()函数。</p>
<h2 id="_read()">_read()</h2><p>_read函数主要负责两件事：</p>
<ol>
<li>从文件读取数据</li>
<li>对文本模式打开的文件，转换回车符。</li>
</ol>
<p><img src="/img/写着玩-运行库/105.PNG" alt=""><br><img src="/img/写着玩-运行库/106.PNG" alt=""><br><img src="/img/写着玩-运行库/107.PNG" alt=""></p>
<p>可以看出，_read就是封装了ReadFile，将真正的文件数据读到该读的地方去(文件缓冲或最终目的地buffer中)，最后对返回值进行检查。</p>
<p>这样，fread的流程就算分析完了。</p>
<p>这里，还有一个遗漏，就是处理换行符的问题，上面提到的单字节缓冲就是用于处理换行的。我们知道ReadFile可以对管道或设备进行处理，前提是管道或设备以文本模式打开。</p>
<p><img src="/img/写着玩-运行库/107.PNG" alt=""><br><img src="/img/写着玩-运行库/108.PNG" alt=""><br><img src="/img/写着玩-运行库/109.PNG" alt=""><br><img src="/img/写着玩-运行库/110.PNG" alt=""><br><img src="/img/写着玩-运行库/111.PNG" alt=""><br><img src="/img/写着玩-运行库/112.PNG" alt=""><br><img src="/img/写着玩-运行库/113.PNG" alt=""></p>
<h2 id="fread_流程总结">fread 流程总结</h2><p><img src="/img/写着玩-运行库/114.PNG" alt=""></p>
<h1 id="0x06_结">0x06 结</h1><ol>
<li>入口函数</li>
<li>I/O初始化</li>
<li>文件缓冲</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>继续坚持。。。</p>
<h1 id="0x01_入口函数和程序初始化">0x01 入口函数和程序初始化</h1><p>不管是在程序的开始还是程序的结束，main既不是最初被调用的，也不是最后被调用的，在main之前]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-窥视内存]]></title>
    <link href="http://kenshichong.github.io/2016/05/08/%E5%86%99%E7%9D%80%E7%8E%A9-%E7%AA%A5%E8%A7%86%E5%86%85%E5%AD%98/"/>
    <id>http://kenshichong.github.io/2016/05/08/写着玩-窥视内存/</id>
    <published>2016-05-08T03:53:09.000Z</published>
    <updated>2016-05-09T00:35:58.979Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>最近状态下滑，没啥说的，基础重要，继续坚持</p>
<h1 id="0x01_程序的内存布局">0x01 程序的内存布局</h1><p>内存，大家再熟悉不过</p>
<h2 id="给出linux进程地址空间布局">给出linux进程地址空间布局</h2><p><img src="/img/写着玩-窥视内存/0.PNG" alt=""></p>
<h2 id="给出很常见的活动记录示意图">给出很常见的活动记录示意图</h2><p><img src="/img/写着玩-窥视内存/1.PNG" alt=""></p>
<h2 id="函数的标准序言和尾声">函数的标准序言和尾声</h2><p><img src="/img/写着玩-窥视内存/2.PNG" alt=""><br><img src="/img/写着玩-窥视内存/3.PNG" alt=""></p>
<h2 id="GCC取消帧指针(ebp)的编译选项">GCC取消帧指针(ebp)的编译选项</h2><p><img src="/img/写着玩-窥视内存/4.PNG" alt=""></p>
<h2 id="小姿势">小姿势</h2><p><img src="/img/写着玩-窥视内存/5.PNG" alt=""><br><img src="/img/写着玩-窥视内存/6.PNG" alt=""><br><img src="/img/写着玩-窥视内存/7.PNG" alt=""><br><img src="/img/写着玩-窥视内存/8.PNG" alt=""><br><img src="/img/写着玩-窥视内存/9.PNG" alt=""></p>
<h2 id="调用惯例">调用惯例</h2><p>函数的调用方和被调用方对函数如何调用有着统一的理解，这种约定称为调用惯例。<br>调用惯例一般包括以下几方面内容：</p>
<p><img src="/img/写着玩-窥视内存/10.PNG" alt=""></p>
<p>默认调用惯例cdecl:</p>
<p><img src="/img/写着玩-窥视内存/11.PNG" alt=""></p>
<p>其他调用惯例：</p>
<p><img src="/img/写着玩-窥视内存/12.PNG" alt=""><br><img src="/img/写着玩-窥视内存/13.PNG" alt=""></p>
<h2 id="函数返回值传递">函数返回值传递</h2><p>我们知道eax是返回值的通道，函数将返回值存储在eax中。但eax本身只有4个字节，对于5-8字节的情况，采用eax和edx联合返回的方式进行。对于超过8字节的，C语言在函数返回时会使用一个临时的栈上内存区域作为中转，结果返回值对象会被拷贝两次。</p>
<p>Windows的MSVC9和linux的gcc都是通过栈上的隐藏参数传递临时对象的地址，只不过在将临时对象写回到实际的目标对象时，MSVC9使用rep movs指令，而gcc使用memcpy函数。</p>
<p>对于C++，它处理返回对象时进行了一个拷贝构造函数的调用以及一次operate=的调用，也就是说，仍然产生了两次拷贝，因此C++的对象同样会产生临时对象。</p>
<p>上面说的返回对象的拷贝情况完全不具备可移植性，不同的编译器产生的结果可能不同。</p>
<h2 id="linux进程堆管理">linux进程堆管理</h2><p>linux提供了两种堆空间的分配方式，即两个系统调用：brk()和mmap()</p>
<p><img src="/img/写着玩-窥视内存/14.PNG" alt=""><br><img src="/img/写着玩-窥视内存/15.PNG" alt=""><br><img src="/img/写着玩-窥视内存/16.PNG" alt=""></p>
<p>也就是说，linux下管理堆最底层的就是这两个系统调用，只用于申请空间，只不过申请空间的方式不同，其他的申请空间的函数都是对这两个系统调用的封装，最终都会经由这两个系统调用中的一个实现</p>
<p><img src="/img/写着玩-窥视内存/17.PNG" alt=""></p>
<p>可以看出来，程序起初是握有一块堆空间的，小空间直接从这个空间中分配，大的使用mmap先分配匿名空间，然后从匿名空间中分配。</p>
<p>malloc到底可以开多大：</p>
<p><img src="/img/写着玩-窥视内存/18.PNG" alt=""><br><img src="/img/写着玩-窥视内存/19.PNG" alt=""></p>
<h2 id="Windows进程堆管理">Windows进程堆管理</h2><p>给出一般情况下，一个Windows进程的地址空间分布：</p>
<p><img src="/img/写着玩-窥视内存/20.PNG" alt=""></p>
<p>对于该图，说明以下几点：</p>
<ol>
<li>栈的位置及个数问题，从图中可以看出，栈的位置在0x00030000和exe文件后面都有分布，这是因为每个线程的栈都是独立的，所以一个进程中有多少个线程，就应该有多少个对应的栈，对于windows来说，每个线程的默认栈大小是1MB，在线程启动时，系统会为它在进程地址空间中分配相应的空间作为栈，所以整个地址空间中栈的位置及个数就不确定。</li>
</ol>
<p><img src="/img/写着玩-窥视内存/21.PNG" alt=""></p>
<p>我们前面说过，对于VirtualAlloc这个系统调用级函数，用它来申请空间时，空间大小必须为页的整数倍，这难免会造成浪费。windows采取的做法是首先通过VirtualAlloc向OS一次性批发大量空间，比如10MB，然后再根据需要分配给程序。分配的算法已经有很经典的实现，所以我们没必要自己写，直接用就行。这个算法的实现位于堆管理器。堆管理器提供了一套与堆相关的API，用来创建，分配，释放和销毁堆空间</p>
<p><img src="/img/写着玩-窥视内存/22.PNG" alt=""><br><img src="/img/写着玩-窥视内存/23.PNG" alt=""><br><img src="/img/写着玩-窥视内存/24.PNG" alt=""></p>
<p>上面提到的默认堆，以及不够用时用VirtualAlloc扩展与前面提到的linux下类似</p>
<p><img src="/img/写着玩-窥视内存/25.PNG" alt=""><br><img src="/img/写着玩-窥视内存/26.PNG" alt=""></p>
<p>看到这，我们要清楚一个关系：malloc包装Heapxxxx，HeapCreate包装VirtualAlloc</p>
<p><img src="/img/写着玩-窥视内存/27.PNG" alt=""></p>
<h2 id="堆分配算法">堆分配算法</h2><p>对于堆分配算法，其问题可以归结为：如何管理一大块连续的内存空间，能够按照需求分配、释放其中的空间。下面介绍几种简单的堆分配算法，只是概述。</p>
<p><strong>空闲链表</strong><br>空闲列表的方法实际上就是把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个列表，直到找到合适大小的块并且将它拆分；当用户释放空间时将它合并到空闲列表中。0day那本书上描述的还是很详细的。</p>
<p><strong>位图</strong></p>
<p><img src="/img/写着玩-窥视内存/28.PNG" alt=""><br><img src="/img/写着玩-窥视内存/29.PNG" alt=""><br><img src="/img/写着玩-窥视内存/30.PNG" alt=""></p>
<p><strong>对象池</strong></p>
<p><img src="/img/写着玩-窥视内存/31.PNG" alt=""><br><img src="/img/写着玩-窥视内存/32.PNG" alt=""></p>
<h1 id="0x02_小结">0x02 小结</h1><p>就看了一些内存的总体布局以及和内存相关的结构的介绍，就酱</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>最近状态下滑，没啥说的，基础重要，继续坚持</p>
<h1 id="0x01_程序的内存布局">0x01 程序的内存布局</h1><p>内存，大家再熟悉不过</p>
<h2 id="给出linux进程地址空间布局">]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-再战动态链接之windows]]></title>
    <link href="http://kenshichong.github.io/2016/04/15/%E5%86%99%E7%9D%80%E7%8E%A9-%E5%86%8D%E6%88%98%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B9%8Bwindows/"/>
    <id>http://kenshichong.github.io/2016/04/15/写着玩-再战动态链接之windows/</id>
    <published>2016-04-15T00:14:31.000Z</published>
    <updated>2016-05-08T03:49:53.463Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>有幸去打了SSCTF的线下，结识了一些菊苣，不得不承认，他们对漏洞的发现速度过于惊人，当时就坐在旁边，一样的用ida看，可大大就是用短短的几小时就找出了漏洞点，并口述了利用方法，自己还在傻傻的撸汇编。。。、</p>
<p>每次打完比赛，有很多收获，知道自己的不足，前两个星期一直在ctftime刷pwn题，对漏洞的发现与利用更加的迅速和效率了，但是对于大量代码的程序，自己的漏洞挖掘能力还是相当不行，主要是一看这么多汇编，硬看的话都得看半天，而且上下文容易忘记，导致自己没有太大信心去挖这里面的漏洞，所以还是得加强自己读码的能力，什么时候能练到一目十行的地步，感觉漏洞的定位应该就很迅速了。。。</p>
<p>想了下，还是基础不行，各种机制不熟，阅读块代码的能力很弱，都是一行行的读，太慢。。。</p>
<p>所以，还是得静下心来巩固基础，了解熟悉各种机制、底层细节，才能在读码上更加得心应手，所以又想起了这本被我遗忘在角落中的自我修养一书。。。</p>
<h1 id="0x01_DLL">0x01 DLL</h1><p>根据题目，毫无疑问，本篇重点就是DLL了，相当于Linux下的共享对象(so)，DLL的扩展名不一定是DLL，也有可能是别的，比如.ocx(OCX控件)或是.CPL(控制面板程序)</p>
<p>像一些基本概念，什么基址，相对地址啊、导入导出啊什么的，就不多谈了。。。</p>
<p>一个DLL在不同的进程中拥有不同的私有数据副本，就像我们前面提到过的ELF共享对象一样，so可以实现代码段地址无关，但DLL并不是，只是在某些情况下可以被多个进程间共享。当然，windows允许将DLL的数据段设置成共享的，即任何进程都可以共享该DLL的同一份数据段。很多时候比较常见的一种做法就是将一些需要进程间共享的变量分离出来，放到另一个数据段中，然后将这个数据段设置成进程间可共享的。</p>
<p><strong>declspec(dllexport)表示该符号是从本dll导出的符号，</strong>declspec(dllimport)表示导入</p>
<p>一些使用dll时应当注意的东西：</p>
<ol>
<li>对于从其他dll中导入的符号，需要用”declspec(dllimport)”显式地声明某个符号为导入符号，这与ELF中的情况不一样，ELF就不需要。</li>
<li>当我们使用某个dll时，需要使用链接器将需要使用dll的的obj文件和该dll对应的lib文件链接在一起产生一个可执行文件。这里的.lib文件，我们在静态链接的时候，介绍过，.lib文件是一组目标文件的集合，在动态链接里面这一点仍然没有错，在动态链接中，.lib文件并不真正包含.c文件的代码和数据，而是用来描述.dll的导出符号，它包含了其他目标文件链接.dll文件时所需要的导入符号以及一部分”桩”代码，又称”胶水代码”，这样的.lib文件又被称为导入库</li>
<li>模块定义文件.def可以控制输出文件的默认堆大小、输出文件名、各个段的属性，默认堆栈大小、版本号等，具体参照MSDN关于.def文件的介绍。</li>
<li>显示运行时链接三大函数：LoadLibrary()，GetProcAddress()，FreeLibrary()</li>
</ol>
<h1 id="0x02_符号导出导入表">0x02 符号导出导入表</h1><h2 id="导出表">导出表</h2><p><img src="/img/写着玩-再战动态链接之windows/0.PNG" alt=""></p>
<p>在PE中，谈到导入导出时，经常把函数和符号混淆在一起，因为PE绝大部分时候只导入导出函数，很少导入导出变量。</p>
<p>又要强势撸一把PE结构姿势了。。。</p>
<p><img src="/img/写着玩-再战动态链接之windows/1.PNG" alt=""><br><img src="/img/写着玩-再战动态链接之windows/2.PNG" alt=""></p>
<p>这3个数组中，前两个很直观，第一个叫导出地址表EAT，它存放的是各个导出函数的RVA，比如第一项是0x1000，它是Add函数的RVA，第二个表是函数名表，它保存的是导出函数的名字，这个表中，所有的函数名是按照ASCII顺序排序的，以便于动态链接器在查找函数名字时可以速度更快(二分查找)</p>
<p>还有一个序号表，对应着序号导入的方式，比较节省空间；函数名表对应着字符串导入的方式。序号的导出方式为：一个导出函数的序号就是函数在EAT中的地址下标加上一个Base值（也就是IMAGE_EXPORT_DIRECTORY中的Base，默认情况下它的值是1)</p>
<p>举个例子，Mul的RVA是0x1020，它在EAT中的下标是1，加上一个Base值1，Mul的导出序号为2。若一个模块A序号方式导入了某个函数，则这个模块A中的导入表就不会保存函数名，而是保存函数的序号，当动态链接时，当寻找一个函数的地址时，只需要根据模块A的导入表中保存的序号，减去IMAGE_EXPORT_DIRECTORY中的Base字段值，得到一个下标，这个下标就是该函数在EAT表中的index值，从而找到地址。</p>
<p>序号的导入毕竟是为了适应以前内存成本高的情况，省去了函数名查找过程，节省了保存函数名表的内存空间，但是，函数的序号可能会变化，因为dll是会更新的，针对序号变化，我们可以手工指定dll的导出序号，但是还是麻烦。</p>
<p>现在硬件条件较好，所以一般采用函数名导入，解决了序号导入的不稳定问题，而且便于理解和程序调试。</p>
<p>但是序号导出方式还是保留着的，还是可以用的。而且一个导出函数肯定有一个序号值(序号值是肯定有的，因为函数在EAT的下标加上Base就是序号值)，但是可以没有函数名。</p>
<p><img src="/img/写着玩-再战动态链接之windows/3.PNG" alt=""></p>
<p>就是函数名表确定位置-&gt;序号表得到index-&gt;根据index查地址表。</p>
<p><img src="/img/写着玩-再战动态链接之windows/4.PNG" alt=""></p>
<h2 id="EXP文件">EXP文件</h2><p>此EXP非彼EXP。。。</p>
<p><img src="/img/写着玩-再战动态链接之windows/5.PNG" alt=""></p>
<h2 id="导出重定向">导出重定向</h2><p><img src="/img/写着玩-再战动态链接之windows/6.PNG" alt=""></p>
<h2 id="导入表">导入表</h2><p>在ELF中，.rel.dyn和.rel.plt两个段中保存了该模块所需要导入的变量和函数的符号，以及所在的模块等信息，而.got和.got.plt则保存着这些变量和函数的真正地址。windows简单粗暴，就叫导入表。</p>
<p><img src="/img/写着玩-再战动态链接之windows/7.PNG" alt=""></p>
<p>别忘了有两种导入方式</p>
<p><img src="/img/写着玩-再战动态链接之windows/9.PNG" alt=""></p>
<h2 id="导入表的核心-IAT">导入表的核心-IAT</h2><p><img src="/img/写着玩-再战动态链接之windows/8.PNG" alt=""><br><img src="/img/写着玩-再战动态链接之windows/10.PNG" alt=""><br><img src="/img/写着玩-再战动态链接之windows/11.PNG" alt=""></p>
<p>化，使得接下来的对该DLL的调用速度与普通方式载入的DLL的速度相差无异。这个有点像ELF的PLT的作用</p>
<p>在不考虑PLT的情况下，IAT相当于GOT。</p>
<p>我们知道，函数调用分为内部调用和外部调用之分，在windows中，对于内部调用，编译器产生的都是直接调用指令；而对于外部调用，产生的是间接调用指令。二者都能达到正常调用的目的。对于windows，区分外部和内部，靠的是一个扩展属性”<strong>declspec(dllimport)”，一旦一个函数被声明为”</strong>declspec(dllimport)”，那么编译器就知道它是外部导入的，就会产生间接调用指令，call ptr [xxxx]这种，而xxxx指向该函数在IAT中的位置，相当于GOT间接跳转，所以外部调用可以正常实现。</p>
<p>接下来是内部调用，对于内部调用，使用的是直接调用指令，即call xxxx这种，但是，如果没有使用那个扩展属性，编译器同样会将外部导入函数处理成内部调用的形式，这样的话，那么就会发生错误，因为内部调用是在链接时就会确定地址的，也就是说在程序装载进行动态链接之前，xxxx就是一个确定的地址，而且不存在重定位，所以如果放任不管，它是找不到要调用函数的入口点的，这样就一定会出错了。</p>
<p>Windows的解决方法就是桩代码了。对于非导入的内部调用，在静态链接时，即可重定位到正确的调用位置，而对于无法找到正确位置的内部调用，将其识别为导入内部调用，即后面的xxxx指向的其实是一段桩代码，而这段桩代码其实就是一段jmp指令，jmp到为该函数。。。球都麻袋，刚才验证了下，发现上面的解释不对，重新解释</p>
<p>首先，在静态链接的过程中，静态链接器即可确定导入了那几个dll，然后他会根据这些dll的导出表生成一个导入表，导入表中包含这些dll的所有导出函数，但是真正在程序中用到几个函数，链接器是不管的，对于用户自定义的函数，在静态链接时，函数调用语句直接被重定位到相应的位置，而如果是非自定义函数，则会遍历导入表，看是否是导入函数，如果既不是自定义也不是导入函数，则会直接报错，如果是导入函数，又分两种情况，一种是带扩展属性”__declspec(dllimport)”的，一种是不带的，但首先我们得知道，IAT在动态链接时是会被刷成正确的函数地址的，也就是说我们在静态链接时只需要将导入函数的调用指令最终指向IAT就算大功告成了，这点在ELF中也类似，ELF为了实现延迟绑定，提高效率，普遍采用PLT机制，即call指令后面跟的是该函数的PLT槽位置，然后通过PLT桩代码跳到GOT，实现正确调用。我们回过头来看windows，带扩展属性的，产生间接调用指令，不带的，产生直接调用指令，那二者怎么达到相同的目的呢？很简单，一个用桩代码，一个不用呗。对于带扩展属性的，是间接调用指令，不用桩代码，call ptr [xxxx]中的xxxx在静态链接时就会指向该函数的IAT槽位置，实现正确调用；不带扩展属性的，静态链接器产生直接调用指令call xxxx，xxxx是桩代码所在位置，借由桩代码的jmp，来跳到IAT槽，从而实现正确调用。</p>
<p>上面的解释看似是解决了这个问题，但是这个桩代码就处于一个很尴尬的境地，我们知道链接器是不产生指令的，那桩代码靠谁产生呢？靠编译器，我也想过，大家来仔细想一想，编译器是将一个.c文件编译成.obj文件，这个.c文件的源码可能引入三种调用，第一种，在.c文件中已经定义了的函数的调用，这种调用在编译成.obj文件时即可用相对偏移调用的形式将call后面的地址确定；第二种，在其他.c文件编译成的.obj文件中定义了的函数调用，这种调用是需要重定位的，将重定位信息放到重定位表中，产生call xxxx指令，然后编译器就不管了；第三种，就是导入函数调用，其实在编译器看来，第二种和第三种是没有区别的，所以对于第二种和第三种，编译器是做的相同的工作，产生call指令，放置重定位信息，然后不管了。可能有的同学回问，为什么编译器在遇到第二种和第三种时，不进行导入表的扫描呢，然后不就可以把第二种和第三种分开了吗？但是有个问题限制了这样做，限制了第二种和第三种的区分。 因为只有一个.obj文件，导入表的信息不全，即无法确定其他.obj文件所依赖的.dll，也就是说只有在静态链接时，当所有的.obj文件都聚齐后，才可以召唤神龙，不，是才可以确定最终的导入表信息，这就使得导入表的扫描只有在静态链接时才能做，编译器无法做，即编译器无法区别第二种和第三种调用，也就无法产生桩代码。而链接器可以扫描全局导入表，即可以在无法将函数调用重定位到正确的地址时，即判断到该函数调用并不是第二种时，链接器就会进行是不是第三种的判断，如果连第三种都不是，则就报错，是第三种的话，还有缓和的余地，但是，又尴尬了，链接器在确定了是第三种调用后，它只能干瞪眼，也就是说他并不能产生桩代码，只能够将call后面的地址重定位到某个地方。</p>
<p>到这里，已经基本理清，就是说，所有的函数调用指令一般都是直接调用指令(大多数情况)对于前两种，静态链接器可以确定call后面的地址(第一种由编译器确定，第二种由链接器重定位)，对于第三种，链接器只能对call后面的地址码进行重定位操作，至于重定位到哪，下面再谈。</p>
<p>分析到这，我们来看windows具体怎么做的，怎么解决的这个问题。答案就是，桩代码是由dll产生的，更深入的说，桩代码来自产生dll文件时伴随的那个LIB文件，即导入库。这里要区分一下导入库和导入表，导入库是dll文件伴随产生的，导入表一般是exe文件中的。编译器在产生导入库时，同一个导出函数会产生两个符号的定义，比如对于函数Add来说，它在导入库中有两个符号，一个是Add，另外一个是<strong>imp</strong>Add，这两个函数的区别是，Add这个符号指向Add函数的桩代码，而<strong>imp</strong>Add指向Add函数在IAT中的位置。所以当我们通过__declspec(dllimport)来声明导入函数</p>
<p>接着上上一段谈，当编译器遇到<strong>declspec(dllimport)时，编译器可以很明显的知道这是第三种调用，拿Add举例，当Add使用</strong>declspec(dllimport)时，当.c中调用Add时，编译器会产生类似call ds:[<strong>imp</strong>Add]的指令；当Add不使用<strong>declspec(dllimport)时，当.c调用Add时，编译器会产生类似call ds:[Add]的指令，，然后编译器就算干完活了，交给链接器进行重定位，链接器会首先在链接文件中找，找不到时，即确定不是第二种调用时，就会去.lib文件中找(这正好解释了为什么链接时需要.lib文件了)，lib中是有符号信息的，然后链接器就会就根据相应的符号在lib中进行查找(Add或</strong>imp<strong>Add)，找不到就报错，找到就会在导入表中存储上相应的符号，符号在带不带</strong>declspec(dllimport)时都是一样的，只是会将不同的符号记录成不同的重定位信息，以便于在将call指令进行重定位，然后就完事了。在运行时，IAT会被刷新前面介绍过，foo会被重定位为桩代码，即call ds:[foo]-&gt;jmp foo-&gt;foo的执行，而<strong>imp</strong>Add是直接定位到函数在</p>
<p>上面一段可以不看，经过一番调试与挣扎，决定还是按书上的思路来进行理解，按照书上的说，使用<strong>declspec(dllimport)时，会在导入表中产生符号</strong>imp前缀修饰的，不使用，直接使用原来的名字，以便于跟.lib文件中的两个符号进行相应的匹配，然后会在导入表中产生相应的符号项(<strong>imp或不带)，但二者在导入表中只能有一个，即对应是否使用。在导入表中产生完相应的IAT项后，静态链接器会将call指令都重定位到相应的符号在IAT中的位置，即call后面的地址码指向该符号在IAT中的唯一项(带</strong>imp或不带)，这样只是在装载时会有所不同，我们知道，装载时，IAT会进行相应的刷新，那么，根据书理解，IAT中带__imp前缀的项的内容会被刷新为函数的入口地址，而不带前缀的项会被刷新为桩代码的地址(dll中是有桩代码的)，由桩代码实行间接跳转。</p>
<p>两种导入方式都支持，但推荐使用__declspec(dllimport)进行导入。就这样，有点太钻牛角尖了。。。</p>
<h1 id="0x03_DLL优化">0x03 DLL优化</h1><h2 id="重定基地址">重定基地址</h2><p>对于基址加载问题，Windows PE采用了一种与ELF不同的办法，叫做装载时重定位，即对每个绝对地址引用都进行重定位。其实就是，每个绝对地址引用+一个偏移，偏移是(|预期基地址-真正加载基地址|)。</p>
<p><img src="/img/写着玩-再战动态链接之windows/12.PNG" alt=""></p>
<h2 id="改变默认基地址">改变默认基地址</h2><p>当然我们在链接生成某DLL时，可以手动指定该DLL的基地址</p>
<p><img src="/img/写着玩-再战动态链接之windows/13.PNG" alt=""></p>
<p>当然，对于已经生成的DLL，我们还是可以指定基地址</p>
<p><img src="/img/写着玩-再战动态链接之windows/14.PNG" alt=""></p>
<p>对于一些系统DLL，Windows在进程空间中专门划出一块0x70000000~0x80000000区域，用于映射这些常用的系统DLL，省去了装载时重定基地址的麻烦。</p>
<h2 id="序号">序号</h2><p>有序号导出，那么，相应的就会有序号导入</p>
<p><img src="/img/写着玩-再战动态链接之windows/15.PNG" alt=""></p>
<p>序号导入比函数名导入快一点，但是在现在的硬件条件下，并不推荐，但是可以用于软件的混淆，试想，如果分析的函数都是序号，那也挺恶心的。</p>
<h2 id="导入函数绑定">导入函数绑定</h2><p>试想，每次运行程序，其所依赖的DLL都会被装载，而且还要进行装载时的重定位操作。但是，大多数情况下，DLL会以同样的顺序被装载到同样的内存地址，所以DLL的导出符号地址这时都是不变的，这样的话，每次程序运行时都要重新进行符号的查找、解析和重定位这个过程就显得很多余。</p>
<p>提供一个合理的思路–将这些导出函数的地址保存到模块的导入表中，这样可以省去每次启动时的符号解析过程。这种优化叫做DLL绑定。有具体的工具支持这种绑定：</p>
<p><img src="/img/写着玩-再战动态链接之windows/16.PNG" alt=""></p>
<p>具体原理为：</p>
<p><img src="/img/写着玩-再战动态链接之windows/17.PNG" alt=""></p>
<p>但是，绑定也有失效的时候：</p>
<ol>
<li>被依赖的DLL更新导致DLL的导出函数地址发生变化；</li>
<li>被依赖的DLL在装载时发生重定基址，导致DLL的装载地址与绑定时不一致。</li>
</ol>
<p>下面提出解决方案：<br>对于第一种情况的失效，很好解决，加一个前后比对的东西就行。PE的做法为，当对程序进行绑定时，对于每个导入的DLL，链接器把DLL的时间戳(Timestamp)和校验和(Checksum，比如MD5)保存到被绑定的PE文件的导入表中。在运行时，Windows会核对将要被装载的DLL与绑定时的DLL版本是否相同，并且确认该DLL没有发生重定基址(这是第二种失效的解决)。没有变化，不用解析；若有变化，正常进行符号解析。</p>
<p><img src="/img/写着玩-再战动态链接之windows/18.PNG" alt=""></p>
<h1 id="0x04_DLL_HELL">0x04 DLL HELL</h1><p>DLL容易发生不兼容问题，称为DLL HELL(DLL 噩梦)。<br>解决DLL HELL的方法：</p>
<p><img src="/img/写着玩-再战动态链接之windows/19.PNG" alt=""><br><img src="/img/写着玩-再战动态链接之windows/20.PNG" alt=""></p>
<p>对于Manifest文件：</p>
<p><img src="/img/写着玩-再战动态链接之windows/21.PNG" alt=""><br><img src="/img/写着玩-再战动态链接之windows/22.PNG" alt=""></p>
<h1 id="0x05_小结">0x05 小结</h1><p><img src="/img/写着玩-再战动态链接之windows/23.PNG" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>有幸去打了SSCTF的线下，结识了一些菊苣，不得不承认，他们对漏洞的发现速度过于惊人，当时就坐在旁边，一样的用ida看，可大大就是用短短的几小时就找出了漏洞点，并口述了利用方法，自己还在傻傻的撸汇编。。。、</p>
]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-简短过渡之共享库的组织]]></title>
    <link href="http://kenshichong.github.io/2016/04/14/%E5%86%99%E7%9D%80%E7%8E%A9-%E7%AE%80%E7%9F%AD%E8%BF%87%E6%B8%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E7%BB%84%E7%BB%87/"/>
    <id>http://kenshichong.github.io/2016/04/14/写着玩-简短过渡之共享库的组织/</id>
    <published>2016-04-14T13:10:30.000Z</published>
    <updated>2016-04-14T16:44:26.511Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>本篇是简短过渡，由于书中该章节中的前3小节讲了一些太过于细致的东西，在本人开来，不是太重要，反而有点麻烦，就不在这里展开了</p>
<p>共享库和共享对象，我们可以把它看做一个概念</p>
<p>本篇姿势较少。。。</p>
<h1 id="0x01_共享库系统路径">0x01 共享库系统路径</h1><p><img src="/img/写着玩-简短过渡之共享库的组织/0.PNG" alt=""></p>
<h1 id="0x02_共享库查找过程">0x02 共享库查找过程</h1><p>知道这个查找路径，对做pwn有一定帮助</p>
<p><img src="/img/写着玩-简短过渡之共享库的组织/1.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/2.PNG" alt=""></p>
<p>不同的系统中，上面的各个文件的名字或路径可能有所不同，比如FreeBSD的SO-NAME缓存文件是/var/run/ld-elf.so.hints，我们可以通过ldconfig的man来查看相应的变化</p>
<h1 id="0x03_环境变量">0x03 环境变量</h1><p>修改程序加载的libc可以通过修改环境变量的方式来实现</p>
<p><img src="/img/写着玩-简短过渡之共享库的组织/3.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/4.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/5.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/6.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/7.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/8.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/9.PNG" alt=""></p>
<h1 id="0x04_共享库的创建和安装">0x04 共享库的创建和安装</h1><h2 id="共享库的创建">共享库的创建</h2><p><img src="/img/写着玩-简短过渡之共享库的组织/10.PNG" alt=""></p>
<p>几个注意的点：</p>
<ol>
<li>不要把输出共享库中的符号和调试信息去掉，也不要使用GCC的”-formit-frame-pointer”选项</li>
<li>使用链接器的”-rpath”选项(或者GCC的-WI(-WI选项后面跟的参数是传递给链接器的)，这种方法可以指定链接产生的目标程序的共享库查找路径)。</li>
<li>当程序使用dlopen()动态加载某个共享模块，而该共享模块须反向引用主模块的符号时，有可能主模块的某些符号因为在链接时没有被反向引用而没有被放到动态符号表里面，导致反向引用失败，ld链接器提供了一个”-export-dynamic”的参数，这个参数表示链接器在生产可执行文件时，将所有全局符号导出到动态符号表，以防止出现上述问题，当然也可以GCC -WI -export-dynamic</li>
</ol>
<h2 id="清除符号信息">清除符号信息</h2><p><img src="/img/写着玩-简短过渡之共享库的组织/11.PNG" alt=""></p>
<h2 id="共享库的安装">共享库的安装</h2><p><img src="/img/写着玩-简短过渡之共享库的组织/12.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/13.PNG" alt=""></p>
<h2 id="共享库构造和析构函数">共享库构造和析构函数</h2><p>顾名思义，就是在共享库被装载时能够进行一些初始化操作，可以用来干一些猥琐的事情。GCC提供了一种构造函数机制：</p>
<p><img src="/img/写着玩-简短过渡之共享库的组织/14.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/15.PNG" alt=""><br><img src="/img/写着玩-简短过渡之共享库的组织/16.PNG" alt=""></p>
<h1 id="0x05_小个结">0x05 小个结</h1><p>没必要小结，就这样。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>本篇是简短过渡，由于书中该章节中的前3小节讲了一些太过于细致的东西，在本人开来，不是太重要，反而有点麻烦，就不在这里展开了</p>
<p>共享库和共享对象，我们可以把它看做一个概念</p>
<p>本篇姿势较少。。。<]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对UPX的一次深入]]></title>
    <link href="http://kenshichong.github.io/2016/02/25/%E5%AF%B9UPX%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B7%B1%E5%85%A5/"/>
    <id>http://kenshichong.github.io/2016/02/25/对UPX的一次深入/</id>
    <published>2016-02-25T02:57:48.000Z</published>
    <updated>2016-03-28T14:27:20.202Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>这次不知道怎么说，心血来潮的成分更多一点吧。自己也有过很多次这种心血来潮，希望这次能够实践下去。。。</p>
<p>记得刚入二进制坑的时候，就接触了脱壳，自己的脱壳技巧也是停留在那时的水平，也只是会一些压缩壳，而且也只是傻逼式的用工具，根本不懂原理，以及为什么这么做。。。</p>
<p>这次准备以UPX为引导，准备实现以下目标：<br><strong> 1. 了解熟悉UPX加壳流程 </strong><br><strong> 2. 逆向分析UPX脱壳桩代码 </strong><br><strong> 3. 分析从OEP处dump的话具体是dump了个什么东西 </strong><br><strong> 4. 分析dump后重建IAT的原理 </strong><br><strong> 5. 根据加壳和脱壳流程，写出自己的脱壳脚本(python或IDApython)</strong><br><strong> 6. 有时间的话，去看看各种压缩算法，估计没时间</strong></p>
<h1 id="GO！">GO！</h1><h1 id="0x01_了解熟悉UPX加壳流程">0x01 了解熟悉UPX加壳流程</h1><p>近阶段时间有限，要干和想干的事情太多，加上近机场ctf我都没开题，所以在前段日子看了近三周源码后决定先搁置一段时间，好好修炼一下pwn，真心被打的有点小郁闷。。。</p>
<p>网上资料真心少啊，本来以为前人有做这方面工作的，结果，并没找到，没办法，自己撸源码。。。</p>
<p>UPX作为一个经典的压缩壳，自己对待它的源码还是很细致的剖析了一下的，所以耗费了大把时间，也想学习下一个小的工程程序它的大体架构是怎样的，毕竟不能只做脚本小子:p。但只看了加壳流程的大半部分，不过，应该可以扯很长时间了。。。</p>
<p>没捷径，一步步来吧，从main开始，由于没看完，所以别妄想我能够从总体上把握所谓的加壳的整体架构和流程之类的，毕竟不是战略家，科科。。。</p>
<p>开扯</p>
<h2 id="参数check">参数check</h2><ol>
<li>_set_abort_behavior：首先设定程序崩溃时所采取的动作，详见<a href="https://msdn.microsoft.com/library/e631wekh%28v=vs.90%29.aspx" target="_blank" rel="external">msdn</a>，用户友好，并没有什么影响</li>
<li>acc_wildargv：并不知道干嘛的</li>
<li>upx_sanity_check()：里面是一系列的断言，进行初步检测</li>
<li>opt-&gt;reset()：opt是声明的一个全局变量，是从options.h中导出的(extern struct options_t *opt;),这是个蛮复杂的结构，从他的具体结构中(注释和变量命名)，我们可以看到UPX所支持的一系列操作，该语句是对该结构的一些变量进行初始化赋值，设定一些默认值。</li>
<li>紧接着是对后缀进行处理。我们知道windows一般都是带.exe这种后缀的，下面的#if,#else预处理就是把这个后缀去掉</li>
<li>set_term(stderr);设置输出终端为标准错误流</li>
<li>下面的预处理是判断两种压缩算法是否可用，不可用输出错误信息，然后直接退出</li>
<li>设置随机种子，下面好像没有用到</li>
<li>参数解析，只对几个很简单的参数(help这种)进行操作，如果存在，输出相关信息</li>
<li>一个并不知道干嘛的预处理</li>
<li>重置终端为标准输入(默认)</li>
<li>参数判断，并作相应处理</li>
<li>只有一个参数，显示提示信息后退出</li>
<li>重置输出为错误输出</li>
<li>还是参数检查-_-</li>
<li>紧接着的语句说明upx支持批量加壳</li>
</ol>
<hr>
<p>参数到这就算检查完了，参数通过检查，则把参数信息记录下来后开始工作，不出意料应该是记录到opt全局变量中去。然后就是重置输出为标准输出，然后进入新世界，do_files</p>
<hr>
<h2 id="do_files(i,argc,argv)">do_files(i,argc,argv)</h2><ol>
<li>对版本的检查，版本大于1显示信息。</li>
<li>初始化静态变量infoheader</li>
<li>从批量的待加壳文件中取出一个，进行单个加壳操作-&gt;do_one_file，后面跟一大堆捕获异常的块，就不看了。</li>
</ol>
<h2 id="do_one_file(iname,oname)">do_one_file(iname,oname)</h2><ol>
<li>检查输入文件的合法性和权限，当输入只读且要在源文件基础上输出会报错</li>
<li>InputFile fi;fi.st = st;fi.sopen(iname, O_RDONLY | O_BINARY, SH_DENYWR);/<em>二进制和只读方式打开文件</em>/</li>
<li>// open output file/<em>创建一个临时输出文件，根据抛出的异常提示信息，可以看出打开输出文件时面临哪些问题</em>/OutputFile fo;</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PackMaster <span class="title">pm</span><span class="params">(&amp;fi, opt)</span></span>;<span class="comment">/*根据opt和fi创建加壳管理对象，这个对象很重要*/</span></span><br><span class="line"><span class="keyword">if</span> (opt-&gt;cmd == CMD_COMPRESS)</span><br><span class="line">	pm.pack(&amp;fo);<span class="comment">/*加壳，参数为fo，结果输出到fo中，着重分析这个函数，加壳算法都在这里面，*/</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PackMaster::pack(OutputFile *fo)</span><br><span class="line">&#123;</span><br><span class="line">    p = getPacker(fi);?*获取加壳文件的格式，支持很多种格式*/</span><br><span class="line">    fi = <span class="literal">NULL</span>;<span class="comment">/*前面都是一些check*/</span></span><br><span class="line">    p-&gt;doPack(fo);<span class="comment">/*得到具体的加壳对象后，下面开始加壳*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Packer *PackMaster::getPacker(InputFile *f)<span class="comment">/*根据文件的类型得到与之相对应的文件加壳对象*/</span></span><br><span class="line">&#123;</span><br><span class="line">    Packer *pp = visitAllPackers(try_pack, f, opt, f);<span class="comment">/*try_pack是一个函数指针，visitAllPackers实际上是对try_pack的一个封装*/</span></span><br><span class="line">    <span class="keyword">if</span> (!pp)<span class="comment">/*用try_pack去不停的尝试，直至匹配到相应的文件类型，然后返回相应的加壳对象*/</span></span><br><span class="line">        throwUnknownExecutableFormat();</span><br><span class="line">    pp-&gt;assertPacker();<span class="comment">//这是返回具体的Packer后，检查具体的Packer的有效性，与前面的检查相同</span></span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Packer* PackMaster::visitAllPackers(<span class="keyword">visit_func_t</span> func, InputFile *f, <span class="keyword">const</span> <span class="keyword">options_t</span> *o, <span class="keyword">void</span> *user)</span><br><span class="line">&#123;</span><br><span class="line">	仅截取部分相关代码</span><br><span class="line">        <span class="keyword">if</span> ((p = func(<span class="keyword">new</span> PackW32Pe(f), user)) != <span class="literal">NULL</span>)<span class="comment">/*我们以最能说明情况的32exe为例*/</span></span><br><span class="line">            <span class="keyword">return</span> p;									<span class="comment">/*与PackExe对象相差dos_exe.force_stub这个东西，这个应该是区分DOS和x32的标志*/</span></span><br><span class="line">        <span class="keyword">delete</span> p; p = <span class="literal">NULL</span>;				<span class="comment">/*对于pe32文件，返回的就是这个对象，该对象在构造的过程中会进行相应的检查*/</span></span><br><span class="line">    &#125;	<span class="comment">/*看下这个对象的继承关系，PackW32PE继承自PeFile,PeFile继承自Packer*/</span></span><br><span class="line">    <span class="keyword">if</span> ((p = func(<span class="keyword">new</span> PackArmPe(f), user)) != <span class="literal">NULL</span>)<span class="comment">/*考虑继承时构造函数的执行顺序问题(一般先执行父类的构造函数)*/</span></span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">/*所以在构造中进行的检查为 */</span></span><br><span class="line">    <span class="keyword">delete</span> p; p = <span class="literal">NULL</span>;<span class="comment">/*计算文件的大小和创建压缩信息显示对象(UI的)UiPacker(Packer)；PeFile检查PE的相关数据结构大小和字节对齐(主要是为了兼容平台；而构造PackW32Pe时只记录了简单的一些变量信息)*/</span>*/</span><br><span class="line">    <span class="keyword">if</span> ((p = func(<span class="keyword">new</span> PackExe(f), user)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<hr>
<p>fi的使命已完成，置空并进入doPack(fo)进行加壳<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fi = <span class="literal">NULL</span>;<span class="comment">/*前面都是一些check*/</span></span><br><span class="line">p-&gt;doPack(fo);<span class="comment">/*得到具体的加壳对象后，下面开始加壳*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="doPack(fo)">doPack(fo)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Packer::doPack(OutputFile *fo)</span><br><span class="line">&#123;</span><br><span class="line">    uip-&gt;uiPackStart(fo);<span class="comment">/*又是UI,更新压缩文件数，可以看出，支持多文件加壳*/</span></span><br><span class="line">    pack(fo);<span class="comment">/*虚函数，需要到相应的具体实现中去看，不同的文件格式有不同的实现这里以pe32为例*/</span></span><br><span class="line">    uip-&gt;uiPackEnd(fo);<span class="comment">/*加壳完成后，输出相应的信息*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doPack()的具体实现就不贴了，到这开始就开始与文件结构有紧密联系了，总的思路就是不同的文件格式有不同的压缩和加壳策略，对应着doPack()的不同实现。</p>
<p>对于文件格式的信息，给出以前学PE的图片，结合图片来看。</p>
<p>ih指IMAGE_FILE_HEADER</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>这次不知道怎么说，心血来潮的成分更多一点吧。自己也有过很多次这种心血来潮，希望这次能够实践下去。。。</p>
<p>记得刚入二进制坑的时候，就接触了脱壳，自己的脱壳技巧也是停留在那时的水平，也只是会一些压缩壳，而且也]]>
    </summary>
    
      <category term="源码说明一切" scheme="http://kenshichong.github.io/tags/%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E%E4%B8%80%E5%88%87/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-怒干动态链接]]></title>
    <link href="http://kenshichong.github.io/2016/02/12/%E5%86%99%E7%9D%80%E7%8E%A9-%E6%80%92%E5%B9%B2%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://kenshichong.github.io/2016/02/12/写着玩-怒干动态链接/</id>
    <published>2016-02-12T04:13:37.000Z</published>
    <updated>2016-04-14T13:25:34.043Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_依旧口胡">0x00 依旧口胡</h1><p>终于到了动态链接，终于到了有意思的地方。。。</p>
<h1 id="0x01_为什么要动态链接">0x01 为什么要动态链接</h1><p>静态链接的一些问题导致了动态链接的实现。</p>
<ol>
<li>内存和磁盘空间的浪费，即相同功能代码模块的重用问题。静态链接使得内存中保存有大量相同的代码，造成浪费。</li>
<li>程序的开发和发布问题。静态链接带来的问题是整个程序中如果有任何模块更新，整个程序就要重新链接、发布给用户。因为一般厂商都是提供程序，而不会提供原代码- _ -。</li>
</ol>
<p>所以，我们有了动态链接的思想。简单来说就是把程序的模块相互分割开来，形成独立的文件，而不再将他们静态的链接在一起，在程序需要运行时才进行链接。这样可以很好的解决上面两个问题，并且对于程序的可扩展性和兼容性有很大的改善</p>
<h1 id="0x02_地址无关代码的实现">0x02 地址无关代码的实现</h1><p>为了实现动态链接，我们需要解决共享地址的冲突问题，为此采用装载时重定位的方法。又叫基址重置。我们在前面静态链接时提到过重定位，大家好好回想一下，那时的重定位叫做链接时重定位，是指在形成二进制文件时，由于目标文件的相互引用，导致一些目标文件中的地址需要重定位，从而链接器在链接所有的目标文件把需要确定的一些地址通过重定位的方式确定下来，然后链接各目标文件从而形成一个可以直接使用的二进制文件，该二进制文件中的虚拟地址都是确定的。而这里的装载时重定位是指要运行的二进制文件中的虚拟地址是不确定的，需要在运行时，装载该二进制文件需要的动态链接文件时才会对该二进制文件中的不定地址通过重定位的方式进行确定。</p>
<p>装载时重定位时解决动态模块制表中有绝对地址引用的办法之一，但他有一个很大的缺点，那就是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势。</p>
<p>为此我们需要实现程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变。所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码(PIC)的技术。</p>
<h2 id="模块中地址引用方式">模块中地址引用方式</h2><p>我们先来看看地址是如何引用的。</p>
<p><img src="/img/写着玩-怒干动态链接/0.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/1.PNG" alt=""></p>
<p>下面来看下这4种方式是怎样产生地址无关代码的。</p>
<p><strong><em> 类型一 模块内部调用或跳转 </em></strong><br>最简单的一种情况，解决策略就是我们前面在静态链接重定位中介绍过的相对位移调用指令的指令格式。举个例子：</p>
<p><img src="/img/写着玩-怒干动态链接/2.PNG" alt=""></p>
<p>这样就实现了模块内部调用或跳转的指令的地址无关性。</p>
<p><strong><em> 类型二 模块内部数据访问 </em></strong><br>首先考虑要解决问题的特点：<br>指令中不能直接包含数据的绝对地址，那么实现地址无关性就只能用相对寻址了。我们知道，一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，也就是说，任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，那么只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。</p>
<p>考虑解决方法：<br>根据前面分析的问题特点知道可以用当前指令地址(PC)加上一个偏移量的方法来达到访问相应变量的目的。</p>
<p>实际中采用的方法：<br>现代的体系结构中，数据的相对寻址往往没有相对于PC的寻址方式，所以ELF用了一个很巧妙的方法来得到当前的PC值，然后再加上一个偏移量就可以达到访问相应变量的目的了。得到PC值的方法很多，看下最常用的一种，也是现在ELF的共享对象里面用的一种方法：</p>
<p><img src="/img/写着玩-怒干动态链接/3.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/4.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/5.PNG" alt=""></p>
<p><strong><em> 类型三 模块间数据访问 </em></strong><br>当程序访问本模块外的数据时，我们知道这个数据的地址在装载时才能确定。ELF解决这种问题的做法是在数据段里面建立一个纸箱这些变量的指针数组，也称为全局偏移表(GOT)。注意这里的所属问题，就是说当一个模块中有本模块外的数据引用时，就会在本模块内生成一个got表，然后还应该会在本模块中的重定位表中(该重定位表是在装载时重定位用的，因为在装载时才能知道模块外的地址，而目标文件的重定位表是在静态链接时重定位用的)添加相应的重定位项，这样在动态链接装载时，当所需的模块加载入内存后，相应的地址也就知道了，这样只需要根据重定位项对GOT表进行修改即可，而不用对指令代码进行修改，指令代码的话，始终都是固定的对GOT表的引用，这样在多进程的情况下，指令代码就可以得到重用，而只需要在不同的进程中根据不同的模块装载地址生成不同的GOT表，也就是说只是多了GOT表(所占空间较小)。</p>
<p><img src="/img/写着玩-怒干动态链接/6.PNG" alt=""></p>
<p>书上的描述是链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在本模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。</p>
<p>对于具体的细节，实际上是根据两个偏移来确定最终的访问地址的，在编译时确定GOT相对于当前指令的偏移，则通过得到PC值然后加上一个偏移量，就可以得到GOT表的位置，然后我们根据变量地址在GOT中的偏移就可以得到变量的地址，变量地址在GOT中的偏移是在变量的具体地址确定时经过简单计算装入GOT表中的。当然GOT中每个地址对应于哪个变量是由编译器决定的.</p>
<p>给个例子：<br><img src="/img/写着玩-怒干动态链接/7.PNG" alt=""></p>
<p><strong><em> 类型四 模块间调用、跳转 </em></strong><br>对于模块间调用、跳转，这里只是提出一个策略、可能性，对于具体的做法，稍后说。</p>
<p>可以采用类型三的方法解决，当然也可以直接在GOT中相应的项保存目标函数的地址，利用GOT进行间接跳转，给个例子：</p>
<p><img src="/img/写着玩-怒干动态链接/8.PNG" alt=""></p>
<p>先得到PC，然后加上一个偏移得到函数地址，然后在通过一个间接调用达到目的。</p>
<h2 id="共享模块的全局变量问题">共享模块的全局变量问题</h2><p><img src="/img/写着玩-怒干动态链接/9.PNG" alt=""></p>
<p>而且，我们知道，由于程序主模块的代码并不是地址无关代码(主模块是二进制可执行文件，它的重定位过程是发生在链接过程中的)，那么它怎么解决这种问题呢？</p>
<p>编译器不管那么多，它在编译的时候会跟普通数据访问方式一样，产生类似这样的代码：movl $0x1,xxxxxx</p>
<p>xxxxxx就是global的地址，不进行代码重定位的情况下，变量的地址必须在链接过程中确定下来。也就是说，这个锅由链接器来接。链接器也是有办法的，它会在创建可执行文件时(此时链接器已经知道该变量是否在同一模块的目标文件中，在的话就正常的进行重定位呗，不在就采用下面的方法)，在它的.bss段创建一个global变量的副本，那么问题就很明显了，现在global变量定义在原先的共享对象中，而在可执行文件的.bss段还有一个副本。如果同一个变量同时存在与多个位置中，这在程序实际运行过程中是不可行的。</p>
<p>解决方法是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。ELF共享库在编译时，默认都把定义在模块内部的全局变量(只针对全局变量)当做定义在其他模块的全局变量，也就是说当做前面所讲的类型4，通过GOT来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，这样该变量在运行时实际上最终只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本；如果该全局变量在程序主模块中没有副本，那么GOT中的相应地址就指向模块内部的该变量副本。</p>
<h1 id="0x04_延迟绑定(PLT)">0x04 延迟绑定(PLT)</h1><p>延迟绑定是为了解决动态链接时的速度问题的。我们知道动态链接比静态链接慢的主要原因是动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址，还有就是动态链接器会寻找并装载所需要的共享对象，然后进行符号查找地址重定位等工作，这些都会导致启动速度减慢。</p>
<p>所以提出延迟绑定的解决办法。在一个程序执行过程中，可能很多函数在程序执行完时都不会被用到。延迟绑定的基本思想就是当函数第一次被用到时才进行上面说的绑定工作。</p>
<p>当我们调用某个外部模块的函数时，通常的做法是通过GOT，为了延迟绑定，在这个中间再次增加一层跳转，这一层间接跳转就是PLT。每个外部函数在PLT中都有一个相应的项，比如bar()函数在PLT中的项的地址我们称之为bar@plt。其实现为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bar@plt:</span><br><span class="line">jmp *(bar@GOT)</span><br><span class="line">push n</span><br><span class="line">push moduleID</span><br><span class="line">jump _dl_runtime_resolve</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/写着玩-怒干动态链接/10.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/11.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/12.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/13.PNG" alt=""></p>
<p>所以外部调用的流程就是，call 外部函数(其实是跳到.plt处的与该函数相对应的代码项)-&gt;bar@plt-&gt;GOT(第一次调用还要-&gt;PLT0)</p>
<h1 id="0x05_动态链接相关结构">0x05 动态链接相关结构</h1><p>动态链接情况下，可执行文件的装载与静态链接情况基本一样。首先操作系统会读取可执行文件的头部，检查文件的合法性，然后从头部中的”Program Header”中读取每个”Segment”的虚拟地址、文件地址和属性，并将它们映射到进程虚拟空间的相应位置。但是，这时候，可执行文件里很多对于外部符号的引用还处于无效地址的状态，所以在映射完可执行文件后，操作系统会先启动一个动态链接器。也就是说，在装载器和真正执行期间，还隔着一个动态链接器、</p>
<h2 id="“-interp”段">“.interp”段</h2><p>“.interp”的内容很简单，里面保存的就是一个字符串，这个字符串就是可执行文件需要的动态链接器的路径。</p>
<p><img src="/img/写着玩-怒干动态链接/14.PNG" alt=""></p>
<p>上图显示的/lib/ld-linux.so.2通常是一个软链接，它指向真正的链接器。</p>
<p><img src="/img/写着玩-怒干动态链接/15.PNG" alt=""></p>
<h2 id="“-dynamic”段">“.dynamic”段</h2><p><img src="/img/写着玩-怒干动态链接/16.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/17.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/18.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/19.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/20.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/21.PNG" alt=""></p>
<h2 id="动态符号表(-dynsym)">动态符号表(.dynsym)</h2><p>在前面的截图中，我们能够看到动态符号表的影子，它可以从.dynamic段中去索引。</p>
<p><img src="/img/写着玩-怒干动态链接/22.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/23.PNG" alt=""></p>
<p>可以看出，动态链接的符号表的结构与静态链接的符号表几乎一样，我们可以简单的将导入函数看做是对其他目标文件的中函数的引用，把导出函数看做是在本目标文件中    定义的函数就可以了。</p>
<h2 id="动态链接重定位表">动态链接重定位表</h2><p>在地址无关代码中，动态链接的可执行文件使用的是PIC方法，但这并不能改变它需要重定位的本质，即PIC模式的共享对象(代码段地址无关)也需要重定位。<br><img src="/img/写着玩-怒干动态链接/24.PNG" alt=""></p>
<p>GOT也是一种需要重定位后才能生成的东西。</p>
<p>动态链接的重定位与静态链接重定位的唯一区别，也是我们一直在强调的一个点，就是目标文件的重定位时在静态链接时完成的，而共享对象的重定位是在装载时完成的。</p>
<p><img src="/img/写着玩-怒干动态链接/25.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/26.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/27.PNG" alt=""></p>
<p>共享对象的数据段是没有办法做到地址无关的，他可能会包含绝对地址的引用，对于这种绝对地址的引用，我们必须在装载时将其重定位。来看个例子：</p>
<p><img src="/img/写着玩-怒干动态链接/28.PNG" alt=""></p>
<p>这里插一嘴，对于非PIC模式编译的模块，外部函数调用的重定位就会出现在.rel.dyn中，而非.rel.plt中。很明显，PIC时，地址都是可以通过PIC中的相对当前指令的位置加上一个固定偏移计算出来(内部的引用就直接用偏移，外部的引用通过相对于GOT的偏移来达到目的)，而非PIC中，代码段不在使用这种相对于当前指令的PIC方法，而是采用绝对地址寻址，所以它需要对代码段直接进行重定位</p>
<h2 id="动态链接时进程堆栈初始化信息">动态链接时进程堆栈初始化信息</h2><p><img src="/img/写着玩-怒干动态链接/29.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/30.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/31.PNG" alt=""></p>
<h1 id="0x06_动态链接的步骤和实现">0x06 动态链接的步骤和实现</h1><p>基本分为3步：启动动态链接器本身；装载所有需要的共享对象；重定位和初始化</p>
<h2 id="动态链接器自举">动态链接器自举</h2><p>前面提到过，动态链接器本身就是一个共享对象。所谓自举就是自己启动自己的过程。</p>
<p><img src="/img/写着玩-怒干动态链接/32.PNG" alt=""></p>
<p>自举代码不能使用全局变量和静态变量(前面在谈到共享模块的全局变量问题时提过，可执行文件会在本数据段内部创建一个副本，共享库在编译时，默认都把定义在模块内部的全局变量当做定义在其他模块的全局变量，就是通过GOT来实现访问)，也不能调用函数，内部函数也不行(这个原因会在后面说)。自举代码结束后，就可以自由的调用函数并且随意访问全局变量了。</p>
<h2 id="装载共享对象">装载共享对象</h2><p><img src="/img/写着玩-怒干动态链接/33.PNG" alt=""></p>
<p>上面的共享对象的装载过程中，我们无法回避一个问题，那就是当两个共享对象中的全局符号同名时，符号的优先级问题。出现这种问题时，解决的方法就是覆盖。我们把这种一个共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象称为共享对象全局符号介入。</p>
<p>当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略。由于存在这种重名符号被直接忽略的问题，当程序使用大量共享对象时应该非常小心符号的重名问题，如果两个符号重名又执行不同的功能，那么 程序运行时可能会将所有该符号的引用解析到第一个被加入全局符号表的使用该符号名的符号，从而导致莫名其妙的错误。</p>
<p>下面要解决上面留下的问题，那就是自举时为啥内部函数也不行的问题。前面介绍PIC时，对于第一类模块内部调用或跳转的处理时，我么简单的将其当做是相对地址调用或跳转。但是，有了全局符号介入后，我们就应该重新考虑一下了。那前面的例子来说，foo函数对于bar函数的调用不能够采用第一类模块内部调用的方法，因为一旦bar函数由于全局符号介入被其他模块中的同名函数覆盖(根据忽略策略，以后载入的所有模块中的同名函数引用都必须指向它)，那么foo如果采用相对地址调用的话，那个相对地址部分就需要重定位，这又与共享对象的地址无关性矛盾。所以对于bar函数的调用，编译器只能采用第三种，即当做模块外部符号处理，bar()函数被覆盖，动态链接器只需要重定位.got.plt，不影响共享对象的代码段。</p>
<p>这里我们总结下，数据访问的重定位问题，要把全局和内部的概念区分清楚：</p>
<ol>
<li>模块内部调用或跳转：PIC模式下，由于全局符号介入问题，采用策略三，即重定位”.got.plt”，从而实现不影响共享对象代码段的目的；非PIC模式下，对于可执行文件，在静态链接生成文件时就已经完成重定位，对于共享对象，在装载时，基址确定后直接对代码段中具体的引用指令进行重定位。</li>
<li>模块内部数据访问：PIC模式下：不论是共享对象还是可执行文件，对于模块内部的数据访问，采用相对于当前指令地址的寻址方式，由于在静态链接形成文件时，内部数据所在的具体地址相对于当前引用该数据的指令是可以确定的，所以说重定位为静态链接时由静态链接器进行完成。</li>
</ol>
<h2 id="重定位和初始化">重定位和初始化</h2><p>上面两步搞完后，链接器会开始重新遍历可执行文件和每个共享对象的重定位表，将所有的GOT/PLT需要修正的进行修正。由于此时动态链接器已经拥有了该进程(所有模块)的全局符号表，所以修正就很自然。</p>
<p>重定位完成后，如果某个恭喜那个对象有”.init”段，那么动态链接器会执行”.init”段中的代码，用以实现共享对象特有的初始化过程，比如最常见的，共享对象中的C++的全局/静态对象的构造就需要通过”.init”段来初始化，相应的，共享对象中还可能有”.finit”段，当进程退出时会执行”.finit”段中的代码，可以用来实现C++全局对象析构之类的操作。</p>
<p>这里需要注意的是，如果进程的可执行文件也有”.init”段，那么动态链接器不会执行它，而是由程序初始化部分代码负责执行。</p>
<p>当完成了重定位和初始化之后，准备工作就OK了，这时就没动态链接器什么卵事了，他就可以把剩下的摊子交给程序的入口，此时程序的入口接过进程的控制权开始执行。</p>
<h2 id="Linux动态链接器的实现">Linux动态链接器的实现</h2><p><img src="/img/写着玩-怒干动态链接/34.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/35.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/36.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/37.PNG" alt=""></p>
<p>这里不对dl_main()进行展开。</p>
<p><img src="/img/写着玩-怒干动态链接/38.PNG" alt=""></p>
<h2 id="显式运行时链接">显式运行时链接</h2><p>就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时卸载，这种共享对象一般被叫做动态装载库，跟一般的共享对象没什么卵区别。这种方便装卸的功能可以用于一些有特殊需求的程序上，比如插件，驱动什么的。</p>
<p>本质上就是提供一组函数来进行在程序运行时调用，linux下是dlopen()、dlsym()、dlerror()、dlclose()，windows下的话就是LoadLibrary()和GetProcAddress()了。</p>
<p>这里介绍一个有意思的点。</p>
<p><img src="/img/写着玩-怒干动态链接/39.PNG" alt=""><br><img src="/img/写着玩-怒干动态链接/40.PNG" alt=""></p>
<p>另外，如果被加载的模块之间有依赖关系，比如模块A依赖于模块B，那么程序员需手工加载被依赖的模块，比如先加载B，再加载A。</p>
<p><img src="/img/写着玩-怒干动态链接/41.PNG" alt=""></p>
<h1 id="0x07_小结下">0x07 小结下</h1><p><img src="/img/写着玩-怒干动态链接/42.PNG" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_依旧口胡">0x00 依旧口胡</h1><p>终于到了动态链接，终于到了有意思的地方。。。</p>
<h1 id="0x01_为什么要动态链接">0x01 为什么要动态链接</h1><p>静态链接的一些问题导致了动态链接的实现。</p>
<ol>
<li]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-狂艹装载]]></title>
    <link href="http://kenshichong.github.io/2016/01/19/%E5%86%99%E7%9D%80%E7%8E%A9-%E7%8B%82%E8%89%B9%E8%A3%85%E8%BD%BD/"/>
    <id>http://kenshichong.github.io/2016/01/19/写着玩-狂艹装载/</id>
    <published>2016-01-19T11:37:30.000Z</published>
    <updated>2016-02-11T15:59:09.399Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>最近有点痴迷一些计算机中的机制、策略等理论姿势，觉得有些机制或策略很有意思，以后会多看些这方面的书籍吧，为挖洞之路打基础。</p>
<h1 id="0x01_开艹-一些杂七杂八的东西">0x01 开艹-一些杂七杂八的东西</h1><p>可执行文件只有装载到内存以后才能被CPU执行，装载强调的是怎样放入内存以及如何放。</p>
<p>对于Windows操作系统来说，它的进程虚拟地址空间划分是操作系统占用2GB，剩2GB给进程。windows有个启动参数可以将操作系统占用的虚拟地址空间减少到1GB，即跟linux一样(linux是系统：进程=1:3)。方法为修改Windows系统盘根目录下的Boot.ini(默认是隐藏的)，加上”/3G”参数：<br><img src="/img/写着玩-狂艹装载/0.PNG" alt=""></p>
<p>程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留内存，而将一些不太常用的数据存放在磁盘里面，这就是动态载入的基本原理。覆盖载入和页映射是两种很典型的动态装载方法，都利用了程序的局部性原理。思想就是程序用到哪个模块就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。</p>
<p>覆盖载入就是覆盖，就是说内存就那么点，满了的话你要再想往里面装载的话，就得覆盖，至于覆盖的策略一般要保证程序能够正常执行，禁止跨树间调用</p>
<p>页映射的话就是，大小按页进行装载入内存，采取的策略是由操作系统定的。</p>
<h1 id="0x02_从OS角度看可执行文件的装载">0x02 从OS角度看可执行文件的装载</h1><p>好长时间没写了，从这开始写，有点不适应，放假放的搞得脑子都不在了，没有思考，真的是彻底的休闲与放松了，但也觉着有点无聊。大年初一，干点事情把。。。</p>
<p>谈到装载，我觉着要理清三个地址的概念，一是文件所在的磁盘地址，二是虚拟内存地址，三是真正的物理内存地址。</p>
<p>我们可以把虚拟内存地址当做是连接磁盘地址与物理内存地址的桥梁，这样来看装载就显得很easy了。</p>
<p>装载是指可执行文件的装载，可执行文件是由目标文件链接而成，以elf为例，我们用一些软件，如readelf等看到的信息，也就是可执行文件中真正存储着的地址信息都是虚拟内存地址信息。装载的过程就是以可执行文件中存储着的虚拟地址信息为参照，将文件在磁盘中要装载到内存中内容给装载到内存中，并建立好相应的映射关系即可。</p>
<p>我们用命令(一般为./elf文件)或者双击执行可执行文件时，基本上都伴随着一个新的进程的创建。创建一个进程(还记得我们在讲OS的时候，讲到过用fork系统调用创建进程)，然后装载相应的可执行文件并且执行，一般分三步：</p>
<ol>
<li>创建独立的虚拟地址空间：创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构，这里是创建虚拟地址空间与真正的物理内存之间的映射，我们在讲OS的时候也详细讲过，所谓的段页式映射，应该还有点印象把。在i386的linux下，首先创建虚拟空间时实际上并不会分配物理空间，只是分配一个页目录就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候在进行设置，前面讲OS的时候也详细介绍过，就是先设置个页目录，连TM一个物理内存页面也不给，等到真正执行的时候，当通过段页式映射到真正的物理内存需要访问相应的数据时，发现通过页错误机制来真正分配物理内存页面，并在分配过后将虚拟内存地址到物理内存地址的映射关系给建立起来(即相应的页表项)。</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该”缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。但是当缺页时，OS它得知道程序当前所需要的页在可执行文件中的哪个位置，这就是虚拟空间与可执行文件之间的映射关系。从某种角度来看，这一步即如何建立这个映射关系是整个装载过程中最重要的一步，也是传统意义上的装载。因为你想，只要完成了这一步，也就是说只要建立了这个映射关系，然后我们把运行权就可以交给程序了，然后段页式访存以及页错误机制就可以照班进行了，然后由于在装载的时候已经建立好映射关系，所以当页错误需要从文件中拿相应的东西时，就可以根据这个在装载时建立的映射关系将相应的页装入内存中，然后接下来的一切就顺其自然了。这个映射存储在内存中，在操作系统内部保存着，当程序执行发生段错误时，它可以通过查找这样的数据结构来定位错误页在可执行文件中的位置。关于这个映射关系是如何建立的，这是本质，也是比较有意思的东西，我们一定不能放过，我们会在后面详细讨论。</li>
<li>将CPU指令寄存器设置成可执行文件入口，启动运行，涉及内核堆栈和用户堆栈的切换，CPU运行权限的切换等等，还记得ljmp吗(算比较底层的分析了)？可以将这一步简单的认为操作系统执行了一个跳转，跳转到可执行文件的入口地址，还记得ELF文件头中保存的入口地址吗？就是那个地址。</li>
</ol>
<p>其实上面啰嗦了一大堆都是老姿势，但没有啰嗦就没有进步，接着啰嗦。。。</p>
<p><img src="/img/写着玩-狂艹装载/1.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/2.PNG" alt=""></p>
<p>好吧，关键问题还是那个可执行文件到虚拟地址映射的数据结构，别急。。。</p>
<h1 id="0x03_进程虚存空间分布">0x03 进程虚存空间分布</h1><h2 id="1-_ELF文件链接视图和执行视图">1. ELF文件链接视图和执行视图</h2><p>从前面的介绍中，我们可以发现一个问题，那就是OS并不是像链接器那样关心各个段的名字以及具体的数据含义等，OS它只关心一些跟装载相关的问题，最主要的就是段的权限。所以，这就存在两个视角，一个是链接视角，与之相对应的是Section，一个是OS视角(执行视角)，与之相对应的是Segment。而我们是上帝视角。一个Segment包含一个或多个属性类似的Section，对于相同权限的段，把它们合并到一起当做一个段进行映射。</p>
<p><img src="/img/写着玩-狂艹装载/3.PNG" alt=""></p>
<p>Segment的概念实际上是从装载的角度重新划分了ELF的各个段。ELF可执行文件中有一个专门的数据结构叫做程序头表用来保存Segment的信息。因为ELF目标文件不需要被装载，所以它没有程序头表，而ELF的可执行文件和共享库文件都有，跟段表结构一样，程序头表也是一个结构体数组，它的结构体为：</p>
<p><img src="/img/写着玩-狂艹装载/4.PNG" alt=""></p>
<p>各成员含义：</p>
<p><img src="/img/写着玩-狂艹装载/5.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/6.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/7.PNG" alt=""></p>
<p>VMA还是蛮重要的一个概念。linux中将<strong>进程虚拟空间</strong>中的一个段叫做虚拟内存区域(VMA)；在windows中将这个叫做虚拟段。就是文件中相应段的偏移与虚拟地址的映射，就是我们说的那个很重要的映射关系。球都麻袋，好像解决了什么问题，没错，VMA就是我们要找的那个描述可执行文件与虚拟地址的映射关系的数据结构，它存储在进程中的某个地方，这样就清楚了。</p>
<p>根据程序头表，OS知道什么该把什么映射到内存中，并根据程序头表中的信息建立相应的VMA，用于描述文件物理偏移与内存虚址的关系，存储在该进程的内存空间中，这样在页错误的时候就可以根据VMA找到需要载入内存的页在文件中的偏移了。</p>
<h2 id="2-_堆和栈">2. 堆和栈</h2><p><img src="/img/写着玩-狂艹装载/8.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/9.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/10.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/11.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/12.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/13.PNG" alt=""></p>
<h2 id="3-_段地址对齐">3. 段地址对齐</h2><p>这小节来探讨具体的物理内存与进程虚拟空间是如何映射的。我们都知道，不论是物理内存还是虚存，都是以页为单位的，一般为4096字节，但是这样如果不考虑优化的话，在映射的时候就会出现物理内存的浪费问题。举个例子：假设我们有一个ELF可执行文件，它有三个段(Segment)需要装载，我们将它们命名为SEG0、SEG1、SEG2。如表：</p>
<p><img src="/img/写着玩-狂艹装载/14.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/15.PNG" alt=""></p>
<p>Unix采用了一个取巧的方法，就是让那些各个段接壤的部分共享一个物理页面，具体的映射情景为：</p>
<p><img src="/img/写着玩-狂艹装载/16.PNG" alt=""></p>
<p>附一张我笔记图：</p>
<p><img src="/img/写着玩-狂艹装载/17.PNG" alt=""></p>
<p>可以看出，3个物理页面在虚存中映射成5个页面。在虚存中，各个段并不是整页整页的占有空间，而在物理内存中，它占有页面的整数倍，但在物存中，每个页面的内容并不是仅有一个段，而可能有多个段，这样就需要物理页面到许村的多次映射，这样看过去的话，虚存就是一段连续的空间。</p>
<p><img src="/img/写着玩-狂艹装载/18.PNG" alt=""></p>
<p>VMA0的起始地址是0x08048000，长度是0x709e5，所以它的结束地址是0x080B89E5，而VMA1因为跟VMA0的最后一个虚拟页面共享一个物理页面，并且映射两遍，所以它的虚拟地址应该是0x080B99E5，又因为段必须是4字节的倍数，则向上取整至0x080B99E8。从上面的映射图我们可以看到，只有共享的那个页面才需要被映射两次，一个进程的虚拟内存空间布局中，最多只多映射2个页面(开始的和结尾的，中间部分只映射一次)，所以这也解释了0x080B99E5=0x080B89E5+0x1000(一个页帧)。可以看到Process Virtual Space是一块连续的空间，且页内容是可重叠的，段内容只遵循了4字节对齐原则以及整个进程虚存空间的页对齐原则。总之呢，原则就是虚存浪费无所谓，毕竟虚存，而且多一次映射的话只是浪费一个存储映射关系的数据结构的空间而已，不浪费物存就OK，划算又粗暴。</p>
<h2 id="4-_进程栈初始化">4. 进程栈初始化</h2><p><img src="/img/写着玩-狂艹装载/19.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/20.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/21.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/22.PNG" alt=""></p>
<h1 id="0x04_linux内核装载ELF过程简介">0x04 linux内核装载ELF过程简介</h1><p>当我们在bash下输入一个命令执行某个ELF程序时，linux系统是怎样装载并执行它的呢？</p>
<p>还是熟悉的fork()。大家应该对fork有印象吧，OS里面详细介绍过。</p>
<p><img src="/img/写着玩-狂艹装载/23.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/24.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/25.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/26.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/27.PNG" alt=""></p>
<p>简单来说就是先用fork在bash中创建一个一模一样的进程，然后用execve进行把进程内容用文件进行覆盖，结合fork和execve函数的具体实现细节，我们可以清楚的了解到ELF文件装载的一个较为详细的过程。</p>
<h1 id="0x05_Windows_PE的装载">0x05 Windows PE的装载</h1><p><img src="/img/写着玩-狂艹装载/28.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/29.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/30.PNG" alt=""><br><img src="/img/写着玩-狂艹装载/31.PNG" alt="">    </p>
<h1 id="0x06_拿来的总结">0x06 拿来的总结</h1><p>一张图完事：</p>
<p><img src="/img/写着玩-狂艹装载/32.PNG" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>最近有点痴迷一些计算机中的机制、策略等理论姿势，觉得有些机制或策略很有意思，以后会多看些这方面的书籍吧，为挖洞之路打基础。</p>
<h1 id="0x01_开艹-一些杂七杂八的东西">0x01 开艹-一些杂七杂八的]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-回顾以前的PE岁月]]></title>
    <link href="http://kenshichong.github.io/2016/01/19/%E5%86%99%E7%9D%80%E7%8E%A9-%E5%9B%9E%E9%A1%BE%E4%BB%A5%E5%89%8D%E7%9A%84PE%E5%B2%81%E6%9C%88/"/>
    <id>http://kenshichong.github.io/2016/01/19/写着玩-回顾以前的PE岁月/</id>
    <published>2016-01-19T07:24:33.000Z</published>
    <updated>2016-01-19T11:36:08.567Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>怎么说呢，看到PE，满满的都是感动，想起了一年前，自己刚开始接触计算机时躲在被窝里怒刷汇编视频与PE视频的岁月了。。。当时自己还是傻白甜，看不懂就看很多遍，强行建立PE姿势，很感谢当初认真的自己吧，也感谢陪伴我度过日子的鱼C论坛，虽然现在很少逛了，希望它越办越好吧。。。</p>
<p>这篇不会讲太多，类似于过渡篇把。结构上的东西也不会讲太多，主要还是记录点有意思的东西。PE都被讲烂了，直接用一些PE工具看结构吧，挺直观的。。。</p>
<h1 id="0x01_PE的前身-COFF">0x01 PE的前身-COFF</h1><p>PE是32位windows的，PE32+是win64的。然而新的PE32+并没有添加任何结构，最大的变化就是把那些原来32位的字段变成了64位，呵呵。。。</p>
<p><img src="/img/写着玩-回顾以前的PE岁月/0.PNG" alt=""></p>
<p>给出COFF目标文件格式：</p>
<p><img src="/img/写着玩-回顾以前的PE岁月/1.PNG" alt=""></p>
<p>COFF文件的文件头部包括了两部分，一个是描述文件总体结构和属性的映像头(Image Header/IMAGE_FILE_HEADER)，另外一个是描述该文件中包含的段属性的段表(Section Table/IMAGE_SECTION_HEADER)。</p>
<h2 id="IMAGE_FILE_HEADER">IMAGE_FILE_HEADER</h2><p><img src="/img/写着玩-回顾以前的PE岁月/2.PNG" alt=""><br><img src="/img/写着玩-回顾以前的PE岁月/3.PNG" alt=""></p>
<h2 id="IMAGE_SECTION_HEADER">IMAGE_SECTION_HEADER</h2><p><img src="/img/写着玩-回顾以前的PE岁月/4.PNG" alt=""><br><img src="/img/写着玩-回顾以前的PE岁月/5.PNG" alt=""><br><img src="/img/写着玩-回顾以前的PE岁月/6.PNG" alt=""></p>
<h2 id="黑魔法1-drectve段">黑魔法1-.drectve段</h2><p>.drectve段实际上是Directive的缩写，它的内容是编译器传递给链接器的指令(Directive)，即编译器希望告诉链接器应该怎样链接这个目标文件。.drectve段的标志位是”0x100A00”，是一些标志位的组合：<br><img src="/img/写着玩-回顾以前的PE岁月/7.PNG" alt=""><br>即该段是信息段，并非程序数据；该段可以在最后链接成可执行文件的时候被抛弃；该段在文件中的对齐方式是1个字节对齐。</p>
<p>我们可以用dumpbin对.drectve进行解析，给出内容：<br><img src="/img/写着玩-回顾以前的PE岁月/8.PNG" alt=""><br><img src="/img/写着玩-回顾以前的PE岁月/9.PNG" alt=""></p>
<h2 id="黑魔法2-调试信息">黑魔法2-调试信息</h2><p>COFF文件中所有以”.debug”开始的段都包含着调试信息。这些段中往往有一些意想不到的信息，也可以算是一个<strong>坑点</strong>。</p>
<p>比如，”.debug$S”表示包含的是符号(Symbol)相关的调试信息段；”.debug$P”表示包含预编译头文件(Precompiled Header Files)相关的调试信息段；”.debug$T”表示包含类型(Type)相关的调试信息段。</p>
<p>给出.debug$S段的输出信息：</p>
<p><img src="/img/写着玩-回顾以前的PE岁月/10.PNG" alt=""></p>
<h2 id="COFF符号表">COFF符号表</h2><p>COFF文件的符号表包含的内容几乎跟ELF文件的符号表一样，主要就是符号名、符号的类型、所在的位置等。</p>
<p>给出符号表的输出信息：</p>
<p><img src="/img/写着玩-回顾以前的PE岁月/11.PNG" alt=""><br><img src="/img/写着玩-回顾以前的PE岁月/12.PNG" alt=""><br><img src="/img/写着玩-回顾以前的PE岁月/13.PNG" alt=""></p>
<h1 id="0x02_Windows下的ELF-PE">0x02 Windows下的ELF-PE</h1><p>PE文件是基于COFF的扩展，它比COFF文件多了几个结构。最主要的变化有两个：第一个是文件最开始的部分不是COFF文件头，而是DOS_MZ可执行文件格式的文件头和桩代码(DOS MZ File Header and Stub，比较有意思的一个结构)；第二个变化是原来的COFF文件头中的”IMAGE_FILE_HEADER”部分扩展成了PE文件的文件头结构”IMAGE_NT_HEADERS”。这个结构包括了原来的”Image Header”及新增的PE扩展头部结构(PE Optional Header)。</p>
<p>给出PE文件的结构：<br><img src="/img/写着玩-回顾以前的PE岁月/14.PNG" alt=""></p>
<p>为了所谓的兼容性-兼容DOS，PE文件的魔数是”MZ”，因为DOS下的可执行文件格式是”MZ”。PE文件中”Image DOS Header”和”DOS Stub”这两个结构也是为了兼容DOS。</p>
<p>“IMAGE_DOS_HEADER”结构其实跟DOS的”MZ”可执行结构的头部完全一样，所以从某个角度看，PE文件其实也是一个”MZ”文件。”IMAGE_DOS_HEADER”的结构中的前两个字节是”e_magic”结构，它是里面包含了”MZ”这两个字母的ASCII码；”e_cs”和”e_ip”两个成员指向程序的入口地址。</p>
<p>当PE可执行映像在DOS下被加载的时候，DOS系统检测到该文件，发现最开始两个字节是”MZ”，于是认为他是一个”MZ”可执行文件。然后DOS系统就将PE文件当做正常的”MZ”文件开始执行。DOS系统会读取”e_cs”和”e_ip”这两个成员的值，以跳转到程序的入口地址。然而PE文件中，”e_cs”和”e_ip”这两个成员并不指向程序真正的入口地址，而是指向文件中的”DOS stub”。”DOS stub”是一段可以在DOS下运行的一小段代码，这段代码的唯一作用是向终端输出一行字：”This program cannot be run in DOS”，然后退出程序，表示该程序不能在DOS下运行。这是PE文件结构兼容DOS “MZ”可执行文件结构的体现。</p>
<h2 id="IMAGE_DOS_HEADER的引导作用">IMAGE_DOS_HEADER的引导作用</h2><p><img src="/img/写着玩-回顾以前的PE岁月/15.PNG" alt=""></p>
<h2 id="IMAGE_NT_HEADERS">IMAGE_NT_HEADERS</h2><p><img src="/img/写着玩-回顾以前的PE岁月/16.PNG" alt=""></p>
<p>这里有必要强调一下，IMAGE_NT_HEADERS包括IMAGE_FILE_HEADER和IMAGE_OPTIONAL_HEADER两个结构，NT才是爸爸，我老是搞混。。。</p>
<p><img src="/img/写着玩-回顾以前的PE岁月/17.PNG" alt=""></p>
<p>给出IMAGE_OPTIONAL_HEADER(x64下叫IMAGE_OPTIONAL_HEADER64)结构定义：</p>
<p><img src="/img/写着玩-回顾以前的PE岁月/18.PNG" alt=""><br><img src="/img/写着玩-回顾以前的PE岁月/19.PNG" alt=""></p>
<p>里面有很多成员，我们捡一些有意思的说，其他的字段也很重要，可以去MSDN查详细信息。总之，这个结构<strong>很重要</strong></p>
<p>Windows在装载PE可执行文件时，往往需要很快的找到一些装载所需要的数据结构，比如<strong>导入表</strong>、<strong>导出表</strong>、<strong>资源</strong>、<strong>重定位表</strong>。这些重要的数据的位置和长度都被保存在一个叫数据目录(Data Directory)的结构里面，其实他就是前面”IMAGE_OPTIONAL_HEADER”结构里面的”DataDirectory”成员，这个成员是一个”IMAGE_DATA<em>DIRECTORY”的结构数组(又是数组→</em>→)</p>
<p>给出_IMAGE_DATA_DIRECTORY结构的定义：</p>
<p><img src="/img/写着玩-回顾以前的PE岁月/20.PNG" alt=""><br><img src="/img/写着玩-回顾以前的PE岁月/21.PNG" alt=""></p>
<p>数组中还包含其他的表，比如导入表、资源表、异常表、重定位表、调试信息表、线程私有存储(TLS)等的地址和长度。这些表多数跟装载和DLL动态链接有关，都很重要。通过解析DataDirectory结构就可以了解这些表的位置和长度</p>
<h1 id="0x03_小结">0x03 小结</h1><p>介绍了Windows下的可执行文件和目标文件格式PE/COFF，与ELF文件很相似。COFF有个很有意思的段叫”.drectve段”，保存的是编译器传递给链接器的命令行参数，可以通过这个段实现指定运行库等功能。</p>
<p>下面即将进入有意思的动态链接与装载部分。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>怎么说呢，看到PE，满满的都是感动，想起了一年前，自己刚开始接触计算机时躲在被窝里怒刷汇编视频与PE视频的岁月了。。。当时自己还是傻白甜，看不懂就看很多遍，强行建立PE姿势，很感谢当初认真的自己吧，也感谢陪伴我度过日]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-强撸静态链接（续）]]></title>
    <link href="http://kenshichong.github.io/2016/01/18/%E5%86%99%E7%9D%80%E7%8E%A9-%E5%BC%BA%E6%92%B8%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>http://kenshichong.github.io/2016/01/18/写着玩-强撸静态链接（续）/</id>
    <published>2016-01-18T11:03:01.000Z</published>
    <updated>2016-01-19T07:22:41.141Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>没啥好说的，接着撸。。。</p>
<h1 id="0x01_静态链接中的空间与地址分配">0x01 静态链接中的空间与地址分配</h1><p>采用相似段合并的策略，即将相同性质的段合并到一起，给张图：<br><img src="/img/写着玩-强撸静态链接（续）/0.PNG" alt=""></p>
<p>要明确虚拟地址空间以及文件空间的概念</p>
<p><img src="/img/写着玩-强撸静态链接（续）/1.PNG" alt=""></p>
<p>在linux下，ELF可执行文件默认从地址0x08048000开始分配。</p>
<p>使用这种将相同性质的段合并策略的链接器一般都采用两步链接的方法：</p>
<p><img src="/img/写着玩-强撸静态链接（续）/2.PNG" alt=""></p>
<p>给定一个例子，方便下面用它来说明一些问题：</p>
<p><img src="/img/写着玩-强撸静态链接（续）/3.PNG" alt=""></p>
<p>采用合并相同性质段时，对于符号地址的确定就显得很简单，就是简单的段基址加偏移。即根据符号表的st_name字段得知该符号的名称，根据st_shndx字段指定段+st_value指定段内偏移可以得到该符号对应的具体信息所在的地址。对于处在b.o中的符号，其相对于基址的偏移为a的text(以text段为例)段的size+st_value。</p>
<h1 id="0x02_符号解析与重定位">0x02 符号解析与重定位</h1><p>这里要跟上面所提到的符号地址的确定区别开，符号地址的确定只是把符号所在的具体地址给计算出来了，而符号解析与重定位侧重于讲解在未链接之前，引用外部符号的位置是什么样子的以及如何将这个在链接过程中确定的地址给回填到相应的引用中，侧重于回填的概念</p>
<p>在未链接之前，我们将a.o目标文件进行反汇编：</p>
<p><img src="/img/写着玩-强撸静态链接（续）/4.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/5.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/6.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/7.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/8.PNG" alt=""></p>
<h2 id="1-_怎么修正(回填)的-重定位表">1. 怎么修正(回填)的-重定位表</h2><p>重定位表专门用来保存这些与重定位相关的信息，告诉链接器哪些指令需要被调整，这些指令的哪些部分需要被调整以及怎么调整，在ELF文件中往往是一个段或多个段。</p>
<p>不算是废话的废话：</p>
<p><img src="/img/写着玩-强撸静态链接（续）/9.PNG" alt=""></p>
<p><strong><em>重定位表的结构定义</em></strong><br><img src="/img/写着玩-强撸静态链接（续）/10.PNG" alt=""></p>
<p><strong><em>ELF32_Rel各字段含义</em></strong><br><img src="/img/写着玩-强撸静态链接（续）/11.PNG" alt=""></p>
<h2 id="2-_符号解析">2. 符号解析</h2><p><img src="/img/写着玩-强撸静态链接（续）/12.PNG" alt=""></p>
<p>重定位过程呢也伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位时，为了确定该符号的目标地址，链接器会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。</p>
<hr>
<h1 id="0xff_坑">0xff 坑</h1><p>这里看到全局符号表我是进行了一番思考的。。。符号表如何组成全局符号表是一个值得思考的问题，结合强弱符号以及符号的修饰及相同符号的合并规则等等来考虑如何实现全局符号表的组成，这些细节由于自己检索能力太烂，所以找不到相关资料，这里就留个坑在这吧，日后希望能填上。。。</p>
<hr>
<p>接着说。。。</p>
<h2 id="3-_指令修正方式">3. 指令修正方式</h2><p><img src="/img/写着玩-强撸静态链接（续）/13.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/14.PNG" alt=""></p>
<p>具体的修正细节：<br><img src="/img/写着玩-强撸静态链接（续）/15.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/16.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/17.PNG" alt=""><br>修正后，在访问时就可以根据具体的访存指令(不同的访存指令对于要访问的地址的计算方式不同，所以为了迎合访存指令，编译器在编译到相关的访存指令时，会事先安排好重定位时采用何种修正方式使得修正后的结果能正好满足这个访存指令的需要)</p>
<p>这里还是要口胡一下，就是比如说mov指令和call指令对于跟在他后面地址操作数的计算方式是不同的，拿call来说，它就认为后面的地址操作数就是要调用的位置与紧跟着call后面的那条语句地址差，这些指令的意思是预先定义的，所以编译器在看见call指令时，如果call后面的地址需要重定位，它就会知道，“哦，原来是call后面的地址需要重定位，根据call的意义，我编译器知道它的重定位修正方式为相对寻址修正”，所以，编译器会在重定位表中填入相对地址修正的信息，就是这样。</p>
<h1 id="0x03_COMMOM块">0x03 COMMOM块</h1><p>为什么会有COMMAOM块：<br>由于弱符号机制允许同一个符号的定义存在于多个文件中，所以可能会导致当一个弱符号定义在多个目标文件中，而他们的类型又不同，而我们知道链接器是不支持符号的类型的，即变量类型对于链接器来说是透明的，那么此时链接器该如何处理，这时就需要COMMON块。</p>
<p>什么是COMMON块：<br>当不同的目标文件需要的COMMON块空间大小不一致时，以最大的那块为准</p>
<p>现在的链接机制在处理弱符号时，采用的就是COMMON块的机制，编译器会将弱符号(典型的弱符号如未初始化的全局变量定义)的类型置为SHN_COMMON类型，对于相同名称不同类型的弱符号，就采用COMMON块机制-以空间最大的那个为准。</p>
<p>在目标文件中，编译器为什么不直接把未初始化的全局变量也当做未初始化的局部静态变量一样处理，为它在BSS段分配空间，而是将其标记为一个COMMON类型的变量？<br><img src="/img/写着玩-强撸静态链接（续）/18.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/19.PNG" alt=""></p>
<h1 id="0x04_C++程序的二进制兼容性问题">0x04 C++程序的二进制兼容性问题</h1><p>C++的一些语言特性使之必须由编译器和链接器共同支持才能完成工作。最主要的有两个方面，一个是C++的重复代码消除，还有一个就是全局构造和析构。</p>
<h2 id="1-_重复代码消除">1. 重复代码消除</h2><p>C++编译器在很多时候会产生重复的代码，比如模板、外部内联函数和虚函数表都有可能在不同的编译单元中生成相同的代码。</p>
<p>比较有效的一个策略就是，拿模板来说，将每个模板的实例代码都单独的存放在一个段里，每个段只包含一个模板实例。用这种段的名字来区别不同的段和相同的段。</p>
<p>这种做法的确被目前主流的编译器采用。GNU GCC编译器和Visual C++编译器都采用了类似的方法。GCC把这种类似的需要在最终链接时合并的段叫”Link Once”，它的做法就是将这种类型的段命名为”.gnu.linkonce.name”，其中”name”是该模板函数实例的修饰后名称。Visual C++编译器做法稍有不同，它吧这种类型的段叫”COMDAT”，这种”COMDAT”段的属性字段(PE文件的段表结构里面的IMAGE_SECTION_HEADER的Characteristic成员)都有IMAGE_SCN_LINK_COMDAT(0x00001000)这个标记，在链接器看到这个标记后，它就认为该段是COMDAT类型的，在链接时会将重复的段丢弃</p>
<p>不仅模板是这样，对于会造成代码重复的机制，这种方法或与此类似的方法都是被采用的。像上面提到的外部内联函数、虚函数表。还有默认构造函数、默认拷贝构造函数和赋值操作符等。</p>
<p><img src="/img/写着玩-强撸静态链接（续）/20.PNG" alt=""></p>
<p><strong>又一问题：</strong><br><img src="/img/写着玩-强撸静态链接（续）/21.PNG" alt=""><br><strong>折中的解决方案-函数级别链接</strong><br><img src="/img/写着玩-强撸静态链接（续）/22.PNG" alt=""></p>
<h2 id="2-_全局构造与析构">2. 全局构造与析构</h2><p>C++的全局对象的构造函数在main之前被执行，C++全局对象的析构函数在main之后执行。linux系统下一般程序的入口是”_start”，这个函数是linux系统库(Glibc)的一部分。</p>
<p><strong><em>黑姿势(以前在某CTF中被坑过)</em></strong><br>当我们的程序与Glibc库链接在一起形成最终可执行文件以后，这个函数(_start)就是程序的初始化部分的入口，程序初始化部分完成一系列初始化过程之后，会调用main函数来执行程序的主体。在main函数执行完以后，返回到初始化部分，它进行一些清理工作，然后结束进程。对于有些场合，程序的一些特定的操作必须在main函数之前被执行，还有一些操作必须在main函数之后被执行，其中很具有代表性的就是C++的全局对象的构造和析构函数。因此ELF文件还定义了两种特殊的段。</p>
<ul>
<li>.init 该段里面保存的是可执行指令，它构成了进程的初始化代码。因此，当一个程序开始运行时，在main函数被调用之前，Glibc的初始化部分安排执行这个段中的代码。</li>
<li>.fini 该段保存着进程终止代码指令。因此，当一个程序的main函数正常退出时，Glibc会安排执行这个段中的代码。</li>
</ul>
<p>这两个段.init和.fini的存在有着特别的目的，如果一个函数放到.init段，在main函数执行前系统就会执行它。同理，假如一个函数放到.fini段，在main函数返回后该函数就会被执行。利用这两个特性，C++的全局构造和析构函数得以实现。</p>
<h2 id="3-_C++与ABI">3. C++与ABI</h2><p><strong><em>ABI介绍</em></strong><br><img src="/img/写着玩-强撸静态链接（续）/23.PNG" alt=""><br>也就是说解决目标文件的跨编译平台问题<br><img src="/img/写着玩-强撸静态链接（续）/24.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/25.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/26.PNG" alt=""></p>
<h2 id="4-_静态库链接">4. 静态库链接</h2><p>我们前面说过，一个静态库可以简单的看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。</p>
<p>通常人们使用”ar”压缩程序将这些目标文件压缩到一起，并且对其编号和索引，以便于查找和索引，就形成了libc.a这个静态库文件。也可以使用”ar”工具来查看静态库包含哪些文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ar</span> -t libc.a</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/写着玩-强撸静态链接（续）/27.PNG" alt=""></p>
<p>VC++页提供了与linux下的ar类似的工具，叫lib.exe。这个程序可以用来创建、提取、列举.lib文件中的内容。使用”lib /LIST libcmt.lib”就可以列举出libcmt.lib中所包含的目标文件。</p>
<p>我们从hello.c出发，来看静态库的链接过程。根据前面的姿势，我们可以知道”printf”函数被定义在”libc.a”中的”printf.o”这个目标文件中。那么，似乎，找到了一种看似可行的链接方法，那就是”hello.c”程序编译出来的目标文件只要和libc.a里面的printf.o连接在一起就可以形成一个可执行文件了。我们来验证一下，使用下面的bash语句编译：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gcc</span> -c -fno-builtin hello.c</span><br></pre></td></tr></table></figure></p>
<p>这里说明一下，使用”-fno-builtin”参数是因为在默认情况下，GCC会自作聪明的将hello world程序中只使用了一个字符串参数的printf替换成puts(<strong>这也算是个坑点</strong>)。<br>然后，我们用ar工具解压libc.a<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ar</span> -x libc.a</span><br></pre></td></tr></table></figure></p>
<p>然后链接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ld</span> hello.o printf.o</span><br></pre></td></tr></table></figure></p>
<p>结果意料中，那就是报错了，链接失败<br><img src="/img/写着玩-强撸静态链接（续）/28.PNG" alt=""></p>
<p>给出编译链接的中间过程的打印结果：<br><img src="/img/写着玩-强撸静态链接（续）/29.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/30.PNG" alt=""><br><img src="/img/写着玩-强撸静态链接（续）/31.PNG" alt=""></p>
<p>为什么静态运行库里面一个目标文件只包含一个函数？比如libc.a里面printf.o只有printf()函数，为什么要这样组织？<br><img src="/img/写着玩-强撸静态链接（续）/32.PNG" alt=""></p>
<hr>
<h1 id="0x05_小结">0x05 小结</h1><p>关于静态链接就到这了，重点是目标文件在被链接成最终可执行文件时，输入目标文件中的各个段是如何被合并到输出文件中的，链接器如何为它们分配在输出文件中的空间和地址。当然比较有意思的就是符号的解析与重定位了，一旦输入段的最终地址被确定，接下来就可以进行符号的解析与重定位了，链接器会把各个输入目标文件中对于外部符号的引用进行解析，把每个段中需要重定位的指令和数据进行修补，使他们都指向正确的位置。</p>
<p>还口胡了一些问题，COMMON块啊等等，总之，静态链接很好理解，恩，就是这样。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>没啥好说的，接着撸。。。</p>
<h1 id="0x01_静态链接中的空间与地址分配">0x01 静态链接中的空间与地址分配</h1><p>采用相似段合并的策略，即将相同性质的段合并到一起，给张图：<br><img]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-硬怼目标文件]]></title>
    <link href="http://kenshichong.github.io/2016/01/17/%E5%86%99%E7%9D%80%E7%8E%A9-%E7%A1%AC%E6%80%BC%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"/>
    <id>http://kenshichong.github.io/2016/01/17/写着玩-硬怼目标文件/</id>
    <published>2016-01-17T12:50:32.000Z</published>
    <updated>2016-01-18T10:59:47.041Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>最近dota有点上头，就是怼，马上就能回家跟基友回家黑店了，我是屌屌的3号位，哈哈哈。。。<br>目标文件，怼起。。。</p>
<h1 id="0x01_目标文件的格式">0x01 目标文件的格式</h1><p>还记得我们前面所说的后缀是.o的文件，就是他了，他就是目标文件的一种，其实他已经很接近可执行文件了，不，它已经可以执行了，只要你给他创造相应的条件的话。所以，我们将目标文件与可执行文件看成是一种类型的文件也未尝不可。在windows下，我们统称为PE-COFF文件格式，在linux下，统称为ELF文件。</p>
<p>还有动态链接库-（DLL &amp; .so），静态链接库-（windows下的.lib,linux的.a）也都是可执行文件的格式，但是静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，可以简单的理解为一个包含有很多目标文件的文件包。</p>
<p>ELF文件类型：<br><img src="/img/写着玩-硬怼目标文件/0.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/1.PNG" alt=""></p>
<h1 id="0x02_ELF文件结构">0x02 ELF文件结构</h1><p>ELF文件基本结构图：<br><img src="/img/写着玩-硬怼目标文件/2.PNG" alt=""></p>
<p>ELF目标文件格式的最前部是ELF文件头(ELF Header)，它包含了描述整个文件的基本属性。比如ELF文件版本、目标机器型号、程序入口地址等。紧接着是ELF文件各个段。其中ELF文件中与段有关的重要结构是段表(Section Header Table)，该表描述了ELF文件包含的所有段的信息。比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。</p>
<h2 id="1-_文件头">1. 文件头</h2><p>可以用readelf命令来详细查看ELF文件：</p>
<p><img src="/img/写着玩-硬怼目标文件/3.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/4.PNG" alt=""></p>
<p><strong><em>ELF文件头(ELF_Ehdr)结构的具体定义：</em></strong><br><img src="/img/写着玩-硬怼目标文件/5.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/6.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/7.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/8.PNG" alt=""></p>
<p><strong><em>ELF文件头结构成员具体含义：</em></strong><br><img src="/img/写着玩-硬怼目标文件/9.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/10.PNG" alt=""></p>
<p><strong><em>ELF文件头中的魔数(前16字节e_ident含义)：</em></strong><br><img src="/img/写着玩-硬怼目标文件/11.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/12.PNG" alt=""></p>
<p><strong><em>文件类型</em></strong><br><img src="/img/写着玩-硬怼目标文件/13.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/14.PNG" alt=""></p>
<p><strong><em>机器类型</em></strong><br><img src="/img/写着玩-硬怼目标文件/15.PNG" alt=""></p>
<h2 id="2-_段表">2. 段表</h2><p><strong><em>段表总体描述</em></strong><br><img src="/img/写着玩-硬怼目标文件/16.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/17.PNG" alt=""></p>
<p>所以，段表就是一个数组。</p>
<p><strong><em>数组成员(ELF32_Shdr结构定义)</em></strong><br><img src="/img/写着玩-硬怼目标文件/18.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/19.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/27.PNG" alt=""></p>
<p><strong><em>由段表视角出发得到的ELF文件布局</em></strong><br><img src="/img/写着玩-硬怼目标文件/20.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/21.PNG" alt=""></p>
<p><strong><em>段描述符(ELF32-Shdr)各字段具体含义</em></strong></p>
<p><strong>段的类型(sh_types)</strong><br><img src="/img/写着玩-硬怼目标文件/22.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/23.PNG" alt=""></p>
<p><strong>段的标志位(sh_flag)</strong><br><img src="/img/写着玩-硬怼目标文件/24.PNG" alt=""></p>
<p>对于系统保留段，下表列出了他们的属性</p>
<p><img src="/img/写着玩-硬怼目标文件/25.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/26.PNG" alt=""></p>
<p><strong>段的链接信息</strong><br><img src="/img/写着玩-硬怼目标文件/28.PNG" alt=""></p>
<h2 id="3-_重定位表">3. 重定位表</h2><p><img src="/img/写着玩-硬怼目标文件/29.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/30.PNG" alt=""></p>
<p>在介绍链接的过程的时候，会详细的介绍重定位表的作用</p>
<h2 id="4-_字符串表">4. 字符串表</h2><p>这是个很重要的表，对于我们把整个ELF文件结构框架搭建起来必不可少<br><img src="/img/写着玩-硬怼目标文件/31.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/32.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/33.PNG" alt=""></p>
<p>即：ELF文件头(e_shstrndx)-&gt;段表中的段表字符串表信息-&gt;段表字符串表-&gt;解析各个段。具体的索引想一下就知道了，这里就口胡下，首先拿到文件头中的e_shstrndx字段的值，得知下标和段表的起始位置，则由段表的起始位置+段表数组的成员大小(40 byte)*下标，可以得到段表字符串表的一些列信息，什么起始偏移，大小啊什么的，那么就可以找到段表字符串表的具体位置了，这时可以把段表字符串表拿到内存，供以后解析各个段时使用，然后再返回段表去解析各个段。</p>
<h2 id="5-_链接的接口-符号">5. 链接的接口-符号</h2><p>每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号，函数名或变量名就是符号名。</p>
<p><strong><em>符号概述</em></strong><br><img src="/img/写着玩-硬怼目标文件/34.PNG" alt=""></p>
<p>由于局部符号、段名、行号等对于其他目标文件来说是”不可见的”，在链接过程中无关紧要，我们只关心全局符号。我们可以使用很多命令来查看ELF文件的符号表，比如上面介绍的readelf、objdump，当然还有nm。</p>
<p><img src="/img/写着玩-硬怼目标文件/35.PNG" alt=""></p>
<p>ELF文件中的符号表往往是文件中的一个段，段名一般叫”.symtab”.符号表的结构很简单，它是一个ELF32_sym结构的数组，每个ELF32_sym结构对应一个符号。这个数组的第一个元素，也就是下标为0的元素为无效的”未定义”符号</p>
<p><strong><em>ELF32_sym结构定义</em></strong><br><img src="/img/写着玩-硬怼目标文件/36.PNG" alt=""><br><strong><em>各字段含义</em></strong><br><img src="/img/写着玩-硬怼目标文件/37.PNG" alt=""></p>
<p>对一些字段的详解：<br><strong>符号类型和绑定信息(st_info)</strong><br>该成员低4位表示符号的类型，高28位表示符号绑定信息，见下表：<br><img src="/img/写着玩-硬怼目标文件/38.PNG" alt=""></p>
<p><strong>符号所在段(st_shndx)</strong><br>如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标；但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊，见下表：<br><img src="/img/写着玩-硬怼目标文件/39.PNG" alt=""></p>
<p><strong>符号值(st_value)</strong><br><img src="/img/写着玩-硬怼目标文件/40.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/41.PNG" alt=""></p>
<p>通过上图中划红线的步骤可以找到该符号所对应的具体内容，比如，函数的话可以找到该函数所对应的具体代码处，而全局初始化变量的话，则可以找到全局初始化变量所对应的具体值。</p>
<p>还是以SimpleSection.o为例：<br><img src="/img/写着玩-硬怼目标文件/42.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/43.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/44.PNG" alt=""></p>
<p><strong><em>符号修饰和函数签名</em></strong><br>对于符号修饰和函数签名问题，它是为了解决符号名冲突问题。很久以前，UNIX下的C语言就规定，C语言源代码文件中的所有全局的变量和函数经过编译以后，相对应的符号名前加上下划线”<em>“。而Fortran语言的源代码经过编译后，所有的符号名前面加上”</em>“，后面也加上”<em>“。现在linux下的GCC编译器，默认去掉了在C语言符号前加”</em>“的这种方式；但是windows平台下的编译器还保持着。VC++编译器，GCC在windows下的版本(cygwin,mingw)都会加”_”。GCC编译器可以通过参数选项”-fleading-underscore”或”-fno-leading-underscore”来打开和关闭是否在C语言符号前加上下划线。</p>
<p><strong>C++符号修饰</strong><br>C++都用过，强大而又复杂。他的很多机制都为符号的管理带来了很多麻烦。比如类、继承、虚机制、重载、名称空间等特性。为了支持这些特性，发明了符号修饰或符号改编的机制。</p>
<p><em>对于函数重载</em><br>给例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">	<span class="keyword">class</span> C2&#123;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">	<span class="keyword">class</span> C &#123;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码中有6个同名函数叫func，但他们的返回类型和参数及所在的名称空间不同。我们引入函数签名以及修饰后名称的概念。一个函数签名对应一个修饰后名称。C++的源代码编译后的目标文件中所使用的符号名是相应的函数和变量的修饰后名称。上面的6个函数的函数签名以及修饰后名称是：</p>
<p><img src="/img/写着玩-硬怼目标文件/45.PNG" alt=""></p>
<p>下面解释下不同的函数签名是怎样修饰的。GCC的基本C++名称修饰方法如下：所有的符号都以”_Z”开头，对于嵌套的名字(在名称空间或在类里面的)，后面紧跟”N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，在以”E”结尾。比如N::C::func经过名称修饰以后就是_ZN1N1C4funcE。对于一个函数来说，他的参数列表紧跟在”E”后面。对于int类型来说，就是字母”i”。所以整个N::C::func(int)函数签名经过修饰为_ZN1N1C4funcEi。更为具体的修饰方法在这不介绍，可以去查GCC名称修饰标准。有工具可以帮我们解析被修饰过的名称，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _ZN1N1C4funcEi</span><br><span class="line">N::C::func(int)</span><br></pre></td></tr></table></figure></p>
<p>这种修饰机制不光用到函数名上，他也被用到全局变量和静态变量上。但有一点需要注意，那就是变量的类型是没有被加入到修饰后名称中的，所以不论这个变量是整形还是浮点型甚至是一个全局对象，他们的名称都是一样的。</p>
<p>不同的编译器厂商的名称修饰方法可能不同，在Visual C++下：</p>
<p><img src="/img/写着玩-硬怼目标文件/46.PNG" alt=""></p>
<p>以int N::C::func(int)这个函数签名来说明VC++修饰规则，其实我们都能猜出来→_→修饰名字由”?”开头，接着是函数名”@”符号结尾的函数名；后面跟着由”@”结尾的类名”C”和名称空间”N”，再一个”@”表示函数的名称空间结束，第一个”A”表示函数调用类型为”__cdecl”(函数调用类型会在以后说)，接着是函数的参数类型及返回值，由”@”结束，最后由”Z”结尾。</p>
<p>其实，VC++的名称修饰规则并没有对外公开。MS提供了一个UNDecorateSymbolName()的API，可以将休市后名称转换成函数签名。</p>
<p>由于不同的编译器采用不同的名字修饰方法，必然会导致由不用编译器编译产生的目标文件无法正常相互链接，这是导致不同编译器之间不能相互操作的主要原因之一(被坑过T_T)。。。</p>
<p><strong><em>extern “C”</em></strong><br><img src="/img/写着玩-硬怼目标文件/47.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/48.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/49.PNG" alt=""></p>
<p><strong><em>弱符号与强符号</em></strong><br><img src="/img/写着玩-硬怼目标文件/50.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/51.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/52.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/53.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/54.PNG" alt=""><br><img src="/img/写着玩-硬怼目标文件/55.PNG" alt=""></p>
<h2 id="6-_调试信息">6. 调试信息</h2><p>在GCC编译时加上”-g”参数编译器就会在产生的目标文件里面加上调试信息</p>
<h1 id="0x03_小结">0x03 小结</h1><p>主要分析了各种目标文件的格式，对于ELF文件的代码段、数据段和BSS段没有过多阐述。详细介绍了ELF文件的文件头、段表、重定位表、字符串表、符号表、调试表等相关结构。</p>
<p>无路时可执行文件、目标文件还是库，他们实际上都是基于段的文件或是这种文件的集合，程序的源代码经过编译以后，按照代码和数据分别存放到相应的段中、编译器(汇编器)还会将一些辅助信息，比如符号、重定位信息等也按照表的方式存放到目标文件中，通常情况下，一个表就是一个段。</p>
<p>有了这些目标文件后，接下来就是如何将他们合起来，形成一个可以使用的程序或更得模块，这就是静态链接的问题，下面会在静态链接的续集介绍</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>最近dota有点上头，就是怼，马上就能回家跟基友回家黑店了，我是屌屌的3号位，哈哈哈。。。<br>目标文件，怼起。。。</p>
<h1 id="0x01_目标文件的格式">0x01 目标文件的格式</h1><p>还记]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写着玩-强撸静态链接]]></title>
    <link href="http://kenshichong.github.io/2016/01/17/%E5%86%99%E7%9D%80%E7%8E%A9-%E5%BC%BA%E6%92%B8%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://kenshichong.github.io/2016/01/17/写着玩-强撸静态链接/</id>
    <published>2016-01-17T11:48:38.000Z</published>
    <updated>2016-01-17T12:49:12.748Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>我写代码，以C的hello world为例，第一遍写时是用VC6，当时就傻逼的抄代码，然后F7，然后就F5，然后就输出了，当时就觉着自己好屌，也觉着VC6好屌。现在长大了，开始学着装逼了，用VS，用gcc，g++，但还是觉着VC6好用，没办法，自己太菜，而且也没写过太多代码，VC6够用了，而且也都习惯了。。。</p>
<p>学了编译之后，才算大体上理解从代码文本到可执行的二进制程序是怎样的一个过程，但是也只是知道了个大概，毕竟现实中真正在用的编译器那都是有好多好多功能的，是很强大的，他的具体过程也远没我想的那么简单，既然学了编译，有了大体框架，那么，现在就来丰富细节吧。。。</p>
<p>编程时，都是写完代码，然后一个按钮，或者一行命令，然后就生成了可执行程序，但这个按钮或命令是做了很多事的，大体分为四个步骤：预处理、编译、汇编、链接。</p>
<p>给张图：</p>
<p><img src="/img/写着玩-强撸静态链接/0.PNG" alt=""></p>
<p>没啥好说的，直接撸。。。</p>
<h1 id="0x01_这条命令干了啥">0x01 这条命令干了啥</h1><p><strong><em>gcc hello.c</em></strong></p>
<h2 id="1-_预编译">1. 预编译</h2><p><img src="/img/写着玩-强撸静态链接/1.PNG" alt=""></p>
<p>预编译过程主要处理那些源代码文件中的以”#”开始的预编译指令。比如”#include”、”#define”等，主要规则如下（这就不截图了，手打加深印象）：</p>
<ol>
<li>将所有的”#define”删除，并且展开所有的宏定义</li>
<li>处理所有条件预编译指令，比如”#if”、”#ifdef”、”#elif”、”#else”、”#endif”。</li>
<li>处理”#include”预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其它文件</li>
<li>删除所有的注释”//“和”/**/“。</li>
<li>添加行号和文件名标识，比如#2”hello.c”2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的#pragma编译器指令，因为编译器要使用</li>
</ol>
<p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题(小技巧get)</p>
<h2 id="2-_编译">2. 编译</h2><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件。该过程相当于如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure></p>
<p>现在版本的GCC把预编译和编译两个步骤合并成一个步骤，使用一个叫做cc1的程序，位于/usr/lib/gcc/i486-linux-gnu/4.1/，所以<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc1 hello.c</span><br></pre></td></tr></table></figure></p>
<p>可以达到相同的效果，或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure></p>
<p>这些都可以得到汇编文件hello.s。对于C语言，这个预编译和编译的程序是ccl，对于C++，是cclplus；Objective-C是cclobj；fortan是f771；java是jc1。所以实际上gcc这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译程序cc1、汇编器as、链接器ld。</p>
<h2 id="3-_汇编">3. 汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。就是根据汇编指令和机器指令的对照表意义翻译就行。对应的指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure></p>
<p>或</p>
<pre><code class="bash">gcc -c hello.c -o hello.o
</code></pre>
<h2 id="4-_链接">4. 链接</h2><p>懒，直接上图：</p>
<p><img src="/img/写着玩-强撸静态链接/2.PNG" alt=""></p>
<p>下面就是一堆编译器到底干了什么的东西，具体的可以参考我以前写的blog，好像是第一篇吧。。。</p>
<p>先到这。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>我写代码，以C的hello world为例，第一遍写时是用VC6，当时就傻逼的抄代码，然后F7，然后就F5，然后就输出了，当时就觉着自己好屌，也觉着VC6好屌。现在长大了，开始学着装逼了，用VS，用gcc，g++，但]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序员的自我修养]]></title>
    <link href="http://kenshichong.github.io/2016/01/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    <id>http://kenshichong.github.io/2016/01/17/程序员的自我修养/</id>
    <published>2016-01-17T07:48:16.000Z</published>
    <updated>2016-01-17T11:45:28.860Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>最近也算是闲下来了，把最近一直想总结的exp给总结完后，就想着找点事干。。。</p>
<p>这两天就去看各个大大的blog，理解了哈希长度扩展攻击，看了一些PHP黑魔法，强势补了下分区的姿势，SSRF啥的。。。但也就是浏览浏览，根本沉不下来心，感觉自己太浮躁了，然后又去看一些自己错过的一些ctf的write up，想着自己去把一些想做的题去重新做一下，但根本找不到真正打比赛时的激情，感觉就像是在咀嚼剩菜，不行，提不起来劲。。。</p>
<p>总不能浪费时间吧，安卓和硬件的话想放假回来搞，现在的心情真心不适合去马上开始一块新的领域，主要是自己真的不想搭环境，想赖着两个队友，他们把环境都搭好，自己直接用~</p>
<p>问了下两个队友，他们也都是在各种总结，所以自己想着还是把近几个月一直在看的这本书给总结下，算是给临近放假的这段时间+寒假找点事干，也让自己静静，沉淀沉淀。。。</p>
<p>这个blog就准备当做自己的一个总结用的东西吧，写的也都是给自己看的一些基础的东西，并不是那么注重质量，就是当做自己忘了某些东西时，有个可以查的地方吧，所以基本都是一些理论的东西，实战很少。</p>
<p>等自己牛逼了，再重新开个blog，介绍各种奇淫技巧也不迟~</p>
<h1 id="0x0-5_关于本系列的口胡">0x0.5 关于本系列的口胡</h1><p>还是会写成一个系列吧。。。</p>
<p>会按照本书的脉络，总结自己认为重要的东西，会尽量注重体系化和结构化，对于一些自己认为太干的货，我还是会加入自己的口水理解，方便自己消化。</p>
<p>跟操作系统会有点联系吧，就是一些较底层的理论姿势，发现自己也是喜欢这些东西。。。</p>
<p>口胡就到这吧，开始漫漫总结之旅。。。</p>
<p>没找到电子版，pdf找的也都是扫描版，所以能手打的就手打了，纯当练习自己的打字速度+加深记忆了，但是自己真的懒，所以截图大法好。。。</p>
<h1 id="0x01_线程的笼统介绍">0x01 线程的笼统介绍</h1><p>线程，有时被称为轻量级进程。一个标准的线程由线程ID，当前指令指针（PC），寄存器集合和堆栈组成，各个线程之间共享程序的内存空间。这里说的寄存器集合并非指真正意义上的物理硬件，一个线程就给一套与它相匹配的寄存器，这。。。这里更偏向于软件，是一种数据结构的概念，还记得操系中的TSS吗，类似于那个概念吧，就是说当线程真正竞争到CPU资源时，他才对这些物理资源实现真正意义上的占有。</p>
<p>相对于多进程应用，多线程在数据共享方面效率要高的多，因为进程间通信限制很多，这些限制是为了防止各种杂七杂八的情况出现。线程的访问很自由，他可以访问进程内存里的所有数据，甚至包括其他线程的堆栈（如果他知道其他线程的堆栈地址）。但线程也是有隐私的，局部变量，函数的参数，线程局部存储（TLS），这些数据是线程私有的。</p>
<p>关于线程的调度问题，具体参考进程调度，差不多。如果想要提高一个线程的被调度率，可以采用提高线程优先级的方法。在windows中，使用BOOL WINAPI SetThreadPriority（HANDLE hThread，int nPriority）；来设置线程的优先级，而linux下与线程相关的操作可以通过pthread库来实现。一般的策略中，IO密集型总是比CPU密集型更容易得到优先级的提升。在优先级调度的环境下，线程的优先级改变一般有三种方式：</p>
<ol>
<li>用户指定优先级</li>
<li>根据进入等待状态的频繁程度提升或降低优先级。频繁等待优先级高，意味着一旦就绪系统就会让他尽量在下个时间片运行</li>
<li>长时间得不到执行而被提升优先级。</li>
</ol>
<p>关于fork，exec，clone以及写时复制、竞争与原子操作，同步与互斥啥的就不啰嗦了，操系里已经写得很清楚了</p>
<p>线程安全是一块烫手的山芋，因为即使合理的使用了锁，也不一定能保证线程安全，这是源于落后的编译器技术已经无法满足日益增长的并发需求。很多看似无错的代码在优化和并发的面前又产生了麻烦。如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="function">thread1		thread2</span><br><span class="line"><span class="title">lock</span><span class="params">()</span></span>;		lock();</span><br><span class="line">x++;		x++;</span><br><span class="line">unlock();	unlock();</span><br></pre></td></tr></table></figure></p>
<p>由于有lock和unlock的保护，x++的行为不会被并发所破坏，那么x的值似乎必然是2了。然而，如果编译器为了提高x的访问速度，把x放到了某个寄存器里，那么我们知道不同线程的寄存器是各自独立的。假设thread1先获得锁，则可能会出现下面的情况：</p>
<p><img src="/img/程序员的自我修养/0.PNG" alt=""></p>
<p>可见在这样的情况下即使正确的加锁，也不能保证线程安全。下面是另一个例子：</p>
<p><img src="/img/程序员的自我修养/1.PNG" alt=""><br><img src="/img/程序员的自我修养/2.PNG" alt=""></p>
<p>此时，如果按照<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r1=y;</span><br><span class="line">切换</span><br><span class="line">y=<span class="number">1</span>;</span><br><span class="line">r2=x;</span><br><span class="line">切换</span><br><span class="line">x=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>这种顺序执行，那么此时r1=r2=0就完全有可能了。看到这，其实是有点崩溃的，这尼玛考虑的问题也太多了吧，老子本来写的对的程序硬生生跑错，但没办法，已经发展成这样子了。所以，我们来看下补救措施：我们可以使用volatile关键字试图阻止过渡优化。volatile可以做到：</p>
<p><img src="/img/程序员的自我修养/3.PNG" alt=""></p>
<p>可见volatile确实可以解决一些问题，但是即使volatile能够阻止编译器调整顺序，也无法阻止CPU动态调度换序，呵呵哒。。。</p>
<p>另一个颇为著名的与换序有关的问题来自于singleton模式的double-check。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> T * pInst = <span class="number">0</span>;</span><br><span class="line"><span class="function">T * <span class="title">GetInstance</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pInst == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	lock();</span><br><span class="line">	<span class="keyword">if</span> (pInst == <span class="literal">NULL</span>)</span><br><span class="line">		pInst = <span class="keyword">new</span> T;</span><br><span class="line">	unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抛开逻辑，这代码乍看没问题，使用了volatile关键字，而lock和unlock防止了多线程竞争导致的麻烦。双重的if在这里另有妙用（防止在lock前进行进程切换而使得代码流程不受我们控制），可以让lock的调用开销降低到最小。</p>
<p>但是，呵呵，这是有问题的，没错，就是CPU的乱序执行。C++里的new其实包含了两个步骤：</p>
<ol>
<li>分配内存</li>
<li>调用构造函数<br>所以pInst = new T包含了三个步骤：</li>
<li>分配内存</li>
<li>在内存的位置上调用构造函数</li>
<li>将内存的地址赋值给pInst</li>
</ol>
<p><img src="/img/程序员的自我修养/4.PNG" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> barrier() __asm()__ volatile (<span class="string">"lwsync"</span>)</span></span><br><span class="line"><span class="keyword">volatile</span> T * pInst = <span class="number">0</span>;</span><br><span class="line"><span class="function">T * <span class="title">GetInstance</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pInst == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	lock();</span><br><span class="line">	<span class="keyword">if</span> (pInst == <span class="literal">NULL</span>)</span><br><span class="line">		T * temp = <span class="keyword">new</span> T;</span><br><span class="line">		barrier();</span><br><span class="line">		pInst = temp;</span><br><span class="line">	unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于barrier的存在，对象的构造一定在barrier执行之前完成，因此当pInst被赋值时，对象总是完好的。</p>
<p>首篇就先到这了。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>最近也算是闲下来了，把最近一直想总结的exp给总结完后，就想着找点事干。。。</p>
<p>这两天就去看各个大大的blog，理解了哈希长度扩展攻击，看了一些PHP黑魔法，强势补了下分区的姿势，SSRF啥的。。。但也就]]>
    </summary>
    
      <category term="人丑就要多读书" scheme="http://kenshichong.github.io/tags/%E4%BA%BA%E4%B8%91%E5%B0%B1%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="reverse related" scheme="http://kenshichong.github.io/categories/reverse-related/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[想起来啥写啥]]></title>
    <link href="http://kenshichong.github.io/2016/01/16/hello-world/"/>
    <id>http://kenshichong.github.io/2016/01/16/hello-world/</id>
    <published>2016-01-16T04:53:00.764Z</published>
    <updated>2016-01-16T04:53:00.764Z</updated>
    <content type="html"><![CDATA[<h1 id="0x10-0x01-0x0A">0x10.0x01.0x0A</h1><p>新年新气象，感觉kenshichong这个id不会跟自己太长时间，起源来自于朋友的一句话，“你们牛逼就行了，我就默默的啃屎”，联想到屎壳郎这种动物，就用了kenshichong这个id。。。所以今天决定换id，就是beet1e了</p>
<p>接下来的计划就是：</p>
<h2 id="0x00">0x00</h2><p>把最近一直在看的书做好总结，看了好多心目中菊苣的blog，感觉理论还是挺重要的，但自己只动脑不动手的习惯得改-_-~!</p>
<h2 id="0x01">0x01</h2><p>打xctf，开始接触misc，crypt，为小队多出点力，争取进线下，能够和各种菊苣见见；</p>
<h2 id="0x02">0x02</h2><p>安卓</p>
<h2 id="0x03">0x03</h2><p>GEEK，智能家电，物联网之类的</p>
<p>希望这些计划都能实现，新的一年，干劲满满，gan ba lei</p>
<h1 id="0x10-0x01-0x07">0x10.0x01.0x07</h1><p>不要走别人认为你走这条路比较好的路，没什么j8意思。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x10-0x01-0x0A">0x10.0x01.0x0A</h1><p>新年新气象，感觉kenshichong这个id不会跟自己太长时间，起源来自于朋友的一句话，“你们牛逼就行了，我就默默的啃屎”，联想到屎壳郎这种动物，就用了kenshichong这个id。。]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[密码系列12-消息认证机制]]></title>
    <link href="http://kenshichong.github.io/2016/01/08/%E5%AF%86%E7%A0%81%E7%B3%BB%E5%88%9712-%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://kenshichong.github.io/2016/01/08/密码系列12-消息认证机制/</id>
    <published>2016-01-08T13:09:12.000Z</published>
    <updated>2016-01-10T15:06:47.957Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>截至目前为止，我们已经讨论了对称密码体制和公钥密码体制，对称密码体制主要用于保护数据的机密性，公钥密码体制分为公钥加密和数字签名，其中公钥加密主要用于保护数据的机密性，数字签名用于保护数据的不可否认性和真实性，但是这两大体制并不能提供对数据完整性的保护，这时就需要消息认证机制来承担起对数据完整性的保护。</p>
<p><img src="/img/密码系列12-消息认证机制/0.PNG" alt=""></p>
<h1 id="0x01_消息认证机制概述">0x01 消息认证机制概述</h1><p>消息认证是一个过程，用以验证接收消息的完整性（未被篡改、插入、删除）。认证是一个过程，消息认证机制有消息认证码（MAC)和散列函数(hash)两大类。</p>
<h2 id="消息认证码">消息认证码</h2><p>消息认证码（MAC）是指消息被一密钥控制的公开函数作用后产生的、用作认证符的、固定长度的数值，也称为密码校验和。</p>
<p>数据认证算法是最为广泛使用的消息认证码，已作为FIPS Publication（FIPS PUB 113）并被ANSI作为X9.17标准。</p>
<p>数据认证算法基于CBC模式的DES算法，其初始向量取为零向量，其中最后一个分组不够64比特的话，可在其右边填充一些0，然后按以下过程计算消息认证码：</p>
<p><img src="/img/密码系列12-消息认证机制/1.PNG" alt=""><br><img src="/img/密码系列12-消息认证机制/2.PNG" alt=""></p>
<p><strong>消息认证码的使用流程</strong></p>
<p><img src="/img/密码系列12-消息认证机制/3.PNG" alt=""></p>
<p>消息认证码的安全性是基于仅通信双方知道密钥K这个前提的。如果仅收发双方知道K，且B计算得到的MAC与接收到的MAC一致，则这一系统就实现了以下功能：</p>
<ol>
<li>完整性：接收方相信发送方发来的消息未被篡改，这是因为攻击者不知道密钥，所以不能够在篡改消息后相应地篡改MAC，而如果仅篡改消息，则接收方计算的新MAC将与收到的MAC不同。</li>
<li>真实性：接收方相信发送方不是冒充的，这是因为除收发双方外再无其他人知道密钥，因此其他人不可能对自己发送的消息计算出正确的MAC。</li>
</ol>
<h2 id="散列函数">散列函数</h2><p>散列函数H是一公开函数，用于将任意长的消息M映射为较短的、固定长度的一个值H(M)，称函数值H(M)为杂凑值、杂凑码或消息摘要。杂凑值是消息中所有比特的函数，即改变消息中任何一个比特或几个比特都会使杂凑码发生改变，这是保证消息完整性的最基本的要求。</p>
<p>散列函数的目的是为需认证的数据产生一个“指纹”。为了能够实现对数据的认证，散列函数应满足几个要求：</p>
<ol>
<li>函数的输入可以是任意长。</li>
<li>函数的输出是固定长。</li>
<li>已知x，求H(x)较为容易，可用硬件或软件实现。</li>
<li>已知h，求使得H(x)=h的x在计算上是不可行的，这一性质称为函数的单向性，称H(x)为单向散列函数。</li>
<li>已知x，找出y(y≠x)使得H(y)=H(x)在计算上是不可行的。</li>
<li>找出任意两个不同的输入x、y，使得H(y)=H(x)在计算上是不可行的。</li>
</ol>
<p>以上6个条件中，前3个是散列函数能用于消息认证的基本要求。第4个条件（即单向性）则对使用秘密值的认证技术极为重要。</p>
<p><strong>散列函数结构</strong></p>
<p><img src="/img/密码系列12-消息认证机制/4.PNG" alt=""></p>
<p>目前使用的大多数散列函数其结构都是迭代型的，如图所示。其中函数的输入M被分为L个分组Y0,Y1,…,YL-1，每一个分组的长度为b比特，最后一个分组的长度不够的话，需对其做填充。</p>
<p>对上图的说明：IV = 初始值；CV = 链接值；Yi = 第i 个输入数据块；f = 压缩算法；n = 散列码的长度;b = 输入块的长度</p>
<h1 id="0x02_几种常用的杂凑算法">0x02 几种常用的杂凑算法</h1><h2 id="1-_MD5杂凑算法">1. MD5杂凑算法</h2><p>由Ron Rivest(没错，就是RSA的那个R)于1992年4月公布（RFC 1320，1321）称为MD5。<br>算法的输入为任意长的消息，分为512比特长的分组，输出为128比特的消息摘要。</p>
<h2 id="MD5算法流程">MD5算法流程</h2><p><strong>明文分组 </strong></p>
<p><img src="/img/密码系列12-消息认证机制/5.PNG" alt=""></p>
<p>对明文的处理分以下两步：</p>
<ol>
<li>对消息填充，使得其比特长在模512下为448，即填充后消息的长度为512的某一倍数减64，留出的64比特备第2步使用。<br>步骤1是必需的，即使消息长度已满足要求，仍需填充。例如，消息长为448比特，则需填充512比特，使其长度变为960，因此填充的比特数大于等于1而小于等于512。<br>填充方式是固定的，即第1位为1，其后各位皆为0。</li>
<li>附加消息的长度用步骤1留出的64比特以little-endian方式来表示消息被填充前的长度。如果消息长度大于2^64，则以2^64为模数取模。<br>Little-endian方式是指按数据的最低有效字节（byte）（或最低有效位）优先的顺序存储数据，即将最低有效字节（或最低有效位）存于低地址字节（或位）。相反的存储方式称为big-endian方式。</li>
</ol>
<p>这两步执行完后，消息的长度为512的倍数（设为L倍）。<br>将消息表示为分组长为512的一系列分组Y0，Y1，…，YL-1，而每一分组又可表示为16个32比特长的字，这样消息中的总字数为N=L×16，因此消息又可按字表示为M[0,…,N-1]。</p>
<p><strong>具体的对明文的处理流程(函数Hmd5)</strong></p>
<p><img src="/img/密码系列12-消息认证机制/6.PNG" alt=""></p>
<p>这里使用128比特长的缓冲区以存储中间结果和最终杂凑值，缓冲区可表示为4个32比特长的寄存器（A，B，C，D），每个寄存器都以little-endian方式存储数据，其初值取为（以存储方式）   A=01234567，B=89ABCDEF， C=FEDCBA98，D=76543210，实际上为67452301，EFCDAB89，98BADCFE，10325476。</p>
<p>函数Hmd5的总体概述：</p>
<p><img src="/img/密码系列12-消息认证机制/7.PNG" alt=""></p>
<p><strong>每轮中压缩函数Hmd5的具体细节</strong></p>
<p><img src="/img/密码系列12-消息认证机制/8.PNG" alt=""></p>
<p>上述过程用图形表示为：</p>
<p><img src="/img/密码系列12-消息认证机制/9.PNG" alt=""></p>
<p>对上图的补充说明：</p>
<ol>
<li><p>T[i]为表T中的第i个字，+为模2^32加法。其中∧，∨，-，分别是逻辑与、逻辑或、逻辑非运算</p>
</li>
<li><p>对于每步中左循环移位的位数s，给出s表：</p>
</li>
</ol>
<p><img src="/img/密码系列12-消息认证机制/10.PNG" alt=""></p>
<ol>
<li>对于图中的x[k]，给出如下说明：</li>
</ol>
<p><img src="/img/密码系列12-消息认证机制/11.PNG" alt=""></p>
<p><strong>流程总结</strong>：</p>
<ol>
<li>总流程图：</li>
</ol>
<p><img src="/img/密码系列12-消息认证机制/6.PNG" alt=""></p>
<p>总流程有4轮，除一些细节外每轮大致一样，每轮有16步</p>
<ol>
<li>每步的操作：</li>
</ol>
<p><img src="/img/密码系列12-消息认证机制/9.PNG" alt=""></p>
<p><strong>对MD5的攻击</strong></p>
<p>我们由生日悖论问题引入对MD5的攻击方法。</p>
<p>生日悖论是考虑这样一个问题：在k个人中至少有两个人的生日相同的概率大于0.5时，k至少多大？</p>
<p>这个问题很简单，学过排列组合的都能很容易计算出来。给出计算方法：</p>
<p><img src="/img/密码系列12-消息认证机制/12.PNG" alt=""></p>
<p>在散列函数中：</p>
<p><img src="/img/密码系列12-消息认证机制/13.PNG" alt=""></p>
<p>就是我们通常所说的散列函数的碰撞问题，上面的图中直接给出了碰撞结论，即若散列函数的输出有2^m个可能的话，那么对于2^(m/2)个随机输入，至少有两个输出相同的概率是大于0.5的，那么运用这个结论，我们就可以对md5实施生日攻击。</p>
<p>对生日攻击的流程：</p>
<p><img src="/img/密码系列12-消息认证机制/14.PNG" alt=""></p>
<p>上图中提到了对消息的变形的概念。将一个消息变形为具有相同含义的另一消息的方法有很多，例如对文件，敌手可在文件的单词之间插入很多“space-space-backspace”字符对，然后将其中的某些字符对替换为“space-backspace-space ”就得到一个变形的消息。</p>
<p>md5生日攻击的成本：上述攻击中如果杂凑值的长为64比特，则敌手攻击成功所需的时间复杂度为O(2^32)。对于MD5而言，MD5作为128比特长的杂凑值来说，找出具有相同杂凑值的两个消息需执行O(2^64)次运算。</p>
<p>插一下：我国山东大学王小云教授（2004）提出的攻击对MD5最具威胁。对于MD5的初始值IV，王小云找到了许多512位的分组对，它们的MD5值相同。所以必须寻找新的杂凑算法，以使其产生的杂凑值更长，且抵抗已知密码分析攻击的能力更强。下面要介绍的SHA即为这样的一个算法。</p>
<h2 id="2-_SHA1杂凑算法">2. SHA1杂凑算法</h2><p>安全杂凑算法(secure hash algorithm, SHA)由美国NIST设计，于1993年作为联邦信息处理标准（FIPS PUB 180）公布。SHA其结构与MD5算法非常类似。<br>算法的输入为小于2^64比特长的任意消息，分为512比特长的分组，输出为160比特长的消息摘要</p>
<h2 id="SHA1流程">SHA1流程</h2><p>毕竟上面介绍了MD5，我们就相较于MD5来看，看看SHA1有什么不同<br><strong>明文的分组</strong></p>
<ol>
<li>对消息填充与MD5的步骤1完全相同。 </li>
<li>附加消息的长度与MD5的步骤2类似，不同之处在于以big-endian方式表示填充前消息的长度。</li>
</ol>
<p><strong>缓冲区的初始化</strong><br>相对于MD5而言，SHA1缓冲区初始化算法使用160比特长的缓冲区存储中间结果和最终杂凑值，缓冲区可表示为5个32比特长的寄存器(A, B, C, D, E)，每个寄存器都以big-endian方式存储数据，其初始值分别为A=67452301，B=EFCDAB89，C=98BADCFB，D=10325476，E=C3D2E1F0。</p>
<p><strong>具体的对明文的处理流程(函数Hsha)</strong></p>
<p><img src="/img/密码系列12-消息认证机制/15.PNG" alt=""></p>
<p>对上图的说明：</p>
<p>以分组为单位对消息进行处理每一分组Yq都经一压缩函数处理，压缩函数由4轮处理过程构成，每一轮又由20步迭代组成。4轮处理过程结构一样，但所用的基本逻辑函数不同，分别表示为f1,f2,f3,f4。</p>
<p>每轮的输入为当前处理的消息分组Yq和缓冲区的当前值A,B,C,D,E，输出仍放在缓冲区以替代A,B,C,D,E的旧值，每轮处理过程还需加上一个加法常量Kt，其中0≤t≤79表示迭代的步数。80个常量中实际上只有4个不同取值，下面给出Kt的取值表：</p>
<p><img src="/img/密码系列12-消息认证机制/16.PNG" alt=""></p>
<p>其中 [x] 为x的整数部分。</p>
<p>第4轮的输出（即第80步迭代的输出）再与第1轮的输入CVq相加，以产生CVq+1，其中加法是缓冲区5个字中的每一个字与CVq中相应的字模2^32相加。</p>
<p>输出消息的L个分组都被处理完后，最后一个分组的输出即为160比特的消息摘要。</p>
<p><strong>每轮中压缩函数的具体细节</strong></p>
<p>给出每轮每步的流程框架图：</p>
<p><img src="/img/密码系列12-消息认证机制/17.PNG" alt=""></p>
<p>对流程的解释说明：</p>
<p><img src="/img/密码系列12-消息认证机制/18.PNG" alt=""></p>
<p>下面说明如何由输入分组（512比特长）导出Wt（32比特长):</p>
<p><img src="/img/密码系列12-消息认证机制/19.PNG" alt=""></p>
<p>即：</p>
<p><img src="/img/密码系列12-消息认证机制/20.PNG" alt=""></p>
<hr>
<h2 id="3-_SHA1_VS_MD5">3. SHA1 VS MD5</h2><p>看完了SHA1，就一句话，跟MD5真TM的像啊。。。</p>
<p>那么，就让我们来对比一下：</p>
<ol>
<li>抗穷搜索攻击的强度：</li>
</ol>
<p>由于SHA和MD5的消息摘要长度分别为160和128，所以用穷搜索攻击寻找具有给定消息摘要的消息分别需做O(2^160)和O(2^128)次运算，而用穷搜索攻击找出具有相同消息摘要的两个不同消息分别需做O(2^80)和O(2^64)次运算。因此SHA抗击穷搜索攻击的强度高于MD5抗击穷搜索攻击的强度。</p>
<ol>
<li>抗击密码分析攻击的强度:</li>
</ol>
<p>由于SHA的设计准则未被公开，所以它抗击密码分析攻击的强度较难判断，似乎高于MD5的强度</p>
<ol>
<li>速度:</li>
</ol>
<p>由于两个算法的主要运算都是模232加法，因此都易于在32位结构上实现。但比较起来,SHA的迭代步数(80步)多于MD5的迭代步数（64步），所用的缓冲区（160比特）大于MD5使用的缓冲区（128比特），因此在相同硬件上实现时，SHA的速度要比MD5的速度慢。</p>
<ol>
<li>简洁与紧致性:</li>
</ol>
<p>两个算法描述起来都较为简单，实现起来也较为简单，都不需要大的程序和代换表。</p>
<ol>
<li>数据的存储方式:</li>
</ol>
<p>MD5使用little-endian方式，SHA使用big-endian方式。两种方式相比看不出哪个更具优势，之所以使用两种不同的存储方式是因为设计者最初实现各自的算法时，使用的机器的存储方式不同。</p>
<h1 id="0x03_超进化！Hash+MAC=HMAC">0x03 超进化！Hash+MAC=HMAC</h1><p>不知道有没有注意到一个问题，就是杂凑算法只是对明文进行了一个压缩，产生了一个数据摘要，没有引入密钥的概念，并没有体现认证性，只保证了数据的完整性。</p>
<p>这是，HMAC应运而生。</p>
<p>数据认证算法是传统上构造MAC最为普遍使用的方法，即基于分组密码的构造方法。但近年来研究构造MAC的兴趣已转移到基于密码散列函数的构造方法(HMAC)。这是因为：密码散列函数(如MD5、SHA)的软件实现快于分组密码(如DES)的软件实现；密码散列函数的库代码来源广泛； 密码散列函数没有出口限制，而分组密码有出口限制。</p>
<p>散列函数并不是为用于MAC而设计的，由于散列函数不使用密钥，因此不能直接用于MAC。</p>
<p>目前已提出了很多将散列函数用于构造MAC的方法，其中HMAC就是其中之一，已作为RFC2104被公布，并在IPSec和其他网络协议(如SSL)中得以应用。</p>
<p>RFC2104列举了HMAC的设计目标：</p>
<ol>
<li>可不经修改而使用现有的散列函数，特别是那些易于软件实现的、源代码可方便获取且免费使用的散列函数。</li>
<li>其中镶嵌的散列函数可易于替换为更快或更安全的散列函数。</li>
<li>保持镶嵌的散列函数的最初性能，不因用于HMAC而使其性能降低。</li>
<li>以简单方式使用和处理密钥。</li>
<li>在对镶嵌的散列函数合理假设的基础上，易于分析HMAC用于认证时的密码强度。</li>
</ol>
<p>其中前两个目标是HMAC被公众普遍接受的主要原因，这两个目标是将散列函数当作一个黑盒使用，这种方式有两个优点: </p>
<ol>
<li>散列函数的实现可作为实现HMAC的一个模块，这样一来，HMAC代码中很大一块就可事先准备好，无需修改就可使用；</li>
<li>如果HMAC要求使用更快或更安全的散列函数，则只需用新模块代替旧模块，例如用实现SHA的模块代替MD5的模块。</li>
</ol>
<h2 id="HMAC算法实现">HMAC算法实现</h2><p>HMAC算法的运行总框图：</p>
<p><img src="/img/密码系列12-消息认证机制/21.PNG" alt=""></p>
<p>总体解释：上图是HMAC算法的运行框图，其中H为嵌入的散列函数(如MD5、SHA)，M为HMAC的输入消息(包括散列函数所要求的填充位)，Yi(0≤i≤L-1)是M的第i个分组，L是M的分组数，b是一个分组中的比特数，n为由嵌入的散列函数所产生的杂凑值的长度，K为密钥，如果密钥长度大于b，则将密钥输入到散列函数中产生一个n比特长的密钥，K+是左边经填充0后的K，K+的长度为b比特，ipad为b/8个00110110，opad为b/8个01011010。</p>
<p><strong>HMAC算法流程</strong></p>
<ol>
<li>K的左边填充0以产生一个b比特长的K+ （例如K的长为160比特，b=512，则需填充44个零字节0x00）。</li>
<li>K+与ipad 逐比特异或以产生b比特的分组Si。</li>
<li>将M链接到Si后。</li>
<li>将H作用于步骤3产生的数据流。</li>
<li>K+与opad逐比特异或,以产生b比特长的分组S0。</li>
<li>将步骤4得到的杂凑值链接在S0后。</li>
<li>将H作用于步骤⑥产生的数据流并输出最终结果。</li>
</ol>
<p>注意，K+与ipad逐比特异或以及K+与opad逐比特异或的结果是将K中的一半比特取反，但两次取反的比特的位置不同。而Si和S0通过散列函数中压缩函数的处理，则相当于以伪随机方式从K产生两个密钥。</p>
<p><strong>HMAC流程简化</strong></p>
<p><img src="/img/密码系列12-消息认证机制/22.PNG" alt=""><br><img src="/img/密码系列12-消息认证机制/23.PNG" alt=""></p>
<h2 id="HMAC算法安全性">HMAC算法安全性</h2><p>基于散列函数构造的MAC的安全性取决于镶嵌的散列函数的安全性，而HMAC最吸引人的地方是它的设计者已经证明了算法的强度和嵌入的散列函数的强度之间的确切关系，证明了对HMAC的攻击等价于对内嵌散列函数的下述两种攻击之一：</p>
<ol>
<li>攻击者能够计算压缩函数的一个输出，即使IV是随机的和秘密的。</li>
<li>攻击者能够找出散列函数的碰撞，即使IV是随机的和秘密的。</li>
</ol>
<p>在第一种攻击中，可将压缩函数视为与散列函数等价，而散列函数的n比特长IV可视为HMAC的密钥。对这一散列函数的攻击可通过对密钥的穷搜索来进行，也可通过第Ⅱ类生日攻击来实施，通过对密钥的穷搜索攻击的复杂度为O（2^n），通过第Ⅱ类生日攻击又可归结为上述第二种攻击。</p>
<p>第二种攻击指攻击者寻找具有相同杂凑值的两个消息，因此就是第Ⅱ类生日攻击。对杂凑值长度为n的散列函数来说，攻击的复杂度为O(2^(n/2))。因此第二种攻击对MD5的攻击复杂度为O(2^64)，就现在的技术来说，这种攻击是可行的。但这是否意味着MD5不适合用于HMAC？</p>
<p>回答是否定的，原因如下：攻击者在攻击MD5时，可选择任何消息集合后脱线寻找碰撞。由于攻击者知道杂凑算法和默认的IV，因此能为自己产生的每个消息求出杂凑值。然而，在攻击HMAC时，由于攻击者不知道密钥K，从而不能脱线产生消息和认证码对。所以攻击者必须得到HMAC在同一密钥下产生的一系列消息，并对得到的消息序列进行攻击。对长128比特的杂凑值来说，需要得到用同一密钥产生的2^64个分组（2^73比特）。在1Gbit/s的链路上，需250000年，因此MD5完全适合于HMAC，而且就速度而言，MD5要快于SHA作为内嵌散列函数的HMAC。</p>
<p>消息认证机制就到这了。。。</p>
<hr>
<p>密码的话，写到这就算告一段落了，写的密码都是一些最基础的东西，但基础最重要嘛。。。感觉密码还是蛮好玩的，但自己还是没入门，所以以后也会加强自己在密码上的学习，有什么在密码上的新发现的话，也会及时更新blog的。。。</p>
<hr>
<p>接下来的话，就要转入总结编写各种exp的计划了，希望能够让自己的pwn更有体系，更加自动化，更上一层楼，就这样。。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>截至目前为止，我们已经讨论了对称密码体制和公钥密码体制，对称密码体制主要用于保护数据的机密性，公钥密码体制分为公钥加密和数字签名，其中公钥加密主要用于保护数据的机密性，数字签名用于保护数据的不可否认性和真实性，但是这]]>
    </summary>
    
      <category term="密码学" scheme="http://kenshichong.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="cryptography" scheme="http://kenshichong.github.io/categories/cryptography/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[密码系列11-数论不白学之椭圆曲线公钥密码算法]]></title>
    <link href="http://kenshichong.github.io/2016/01/08/%E5%AF%86%E7%A0%81%E7%B3%BB%E5%88%9711-%E6%95%B0%E8%AE%BA%E4%B8%8D%E7%99%BD%E5%AD%A6%E4%B9%8B%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    <id>http://kenshichong.github.io/2016/01/08/密码系列11-数论不白学之椭圆曲线公钥密码算法/</id>
    <published>2016-01-08T02:41:43.000Z</published>
    <updated>2016-01-08T13:09:54.218Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡背景">0x00 口胡背景</h1><p>Neal Koblitz和Victor Miller在1985年分别提出了椭圆曲线密码体制(ECC)，它是迄今为止被实践证明安全有效的三类公钥密码体制之一。<br>1998年被ISO/IEC定为数字签名标准，2000年2月定为IEEE标准<br>椭圆曲线公钥密码算法跟我们上篇介绍的ElGamal有点类似，安全性都是基于离散对数问题，不过椭圆曲线公钥密码算法的离散对数问题有些特殊</p>
<h1 id="0x01_椭圆曲线密码相关概念">0x01 椭圆曲线密码相关概念</h1><ol>
<li>椭圆曲线的定义：</li>
</ol>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/0.PNG" alt=""></p>
<p>在二维坐标系中表示为：</p>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/1.PNG" alt=""></p>
<ol>
<li>椭圆曲线公钥密码算法所需运算：</li>
</ol>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/2.PNG" alt=""></p>
<p>点的加法运算并不是空穴来风，随便定义了一个运算法则，在图上它是有具体意义的，显得很直观：</p>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/4.PNG" alt=""></p>
<p>p和q的加法描述为：过p，q两点做一条直线，这条直线与椭圆曲线的另一交点(除p，q外的交点)关于x轴的对称点定义为p+q得到的点s。</p>
<p>但是，在椭圆曲线公钥密码算法中，该椭圆曲线上的点我们并不是全部用到，我们只用整数，椭圆曲线上的整数点定义的集合：</p>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/5.PNG" alt=""></p>
<p>但并不是所有的整数点都满足我们的要求，我们还要对这些整数点进行筛选，下面给出Ep(a,b)集合的生成方法：</p>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/6.PNG" alt=""></p>
<p>也就是说，在椭圆曲线密码算法中，我们只用到了上面所说的Ep(a,b)集合中的点，我们只对这些点进行相应的运算，比如我们上面介绍的加法运算。</p>
<p>举个E23(1,1)的例子：</p>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/7.PNG" alt=""></p>
<p>还记得我们上面在刚开始提到的椭圆曲线上的无穷远点O吗，我们来看加法运算加入无穷远点后会有什么变化：</p>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/8.PNG" alt=""></p>
<p>举个最简单的计算例子：</p>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/9.PNG" alt=""><br><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/10.PNG" alt=""></p>
<p>既然我们上面详细介绍了椭圆曲线上的加法运算，那么下面密码算法中肯定是要用到的，为了下面的应用，我们再给两个定义：</p>
<ol>
<li>mP = P + P +…+ P (m个P)</li>
<li>P是椭圆曲线E上的一个点，若存在最小的正整数n，使得nP = O，则称n是P的阶数。</li>
</ol>
<p>OK，有了这些前置姿势，我们已经有资格来揭开椭圆曲线公钥密码算法的真面目了。。。</p>
<h1 id="0x02_椭圆曲线密码流程">0x02 椭圆曲线密码流程</h1><h2 id="1-_密钥生成">1. 密钥生成</h2><p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/11.PNG" alt=""></p>
<h2 id="2-_加密运算">2. 加密运算</h2><p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/12.PNG" alt=""></p>
<h2 id="3-_解密运算">3. 解密运算</h2><p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/13.PNG" alt=""></p>
<p>又是例子。。。</p>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/14.PNG" alt=""></p>
<p>看到例子是不是有点疑惑？欲发往A的消息嵌入到椭圆曲线上的点Pm=(562,201)是什么鬼？</p>
<p>由于椭圆曲线密码算法是在集合Ep(a,b)上进行的运算，所以，我们想要用椭圆曲线对明文加密，我们首先要将明文转化为我们要使用的椭圆曲线上的点。</p>
<p>还记得我们前面介绍的二次剩余吗？好像现在就它没用到了吧。什么叫不白学，学了就会用好吧。给出如下明文到椭圆曲线上的点的转化规则：</p>
<p><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/15.PNG" alt=""></p>
<p>流程就是这么简单。</p>
<h1 id="0x03_椭圆曲线密码体制优点">0x03 椭圆曲线密码体制优点</h1><p>首先来谈谈椭圆曲线密码的安全性，前面也说过了安全性基于离散对数问题。具体描述为：在椭圆曲线群Ep(a,b)上考虑方程Q=kP，其中P，Q∈Ep(a,b)，k&lt;p，则由k和P易求Q，但由P、Q求k则是困难的。<br>这就是椭圆曲线上的离散对数问题，可应用于公钥密码体制.</p>
<p>优点都是对比出来的，这里的对比对象是基于有限域上离散对数问题的公钥体制。与基于有限域上离散对数问题的公钥体制相比，椭圆曲线密码体制有如下优点:</p>
<ol>
<li>安全性高：<img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/16.PNG" alt=""></li>
<li>密钥量小：<img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/17.PNG" alt=""></li>
</ol>
<p>计算量小、处理速度快，这里的处理速度快是指在私钥的处理速度上(解密和签名)，ECC远比RSA快得多，但是公钥加密速度椭圆曲线更慢。</p>
<ol>
<li>灵活性好：p一定的情况下，其上的集合是确定的. 而椭圆曲线Ep(a,b)可以通过改变曲线参数，得到不同的曲线，具有丰富的多选择性.</li>
</ol>
<h1 id="0x04_公钥密码与对称密码比较之各有千秋">0x04 公钥密码与对称密码比较之各有千秋</h1><ol>
<li>公钥密码体制产生密钥很麻烦，比如RSA受到素数产生技术的限制</li>
<li>公钥密码体制速度慢，较对称密码算法慢几个数量级</li>
<li>对称密码算法，密钥短，速度快</li>
<li>公钥密码算法，密钥长，速度慢</li>
<li>对称密码算法用于大量明文加密</li>
<li>公钥密码算法用于少量数据加密，如DES密钥的加密</li>
</ol>
<p>两者各有用处，我们要发挥他们各自的优势来为我们服务：<br><img src="/img/密码系列11-数论不白学之椭圆曲线公钥密码算法/18.PNG" alt=""></p>
<hr>
<p>公钥密码体制到这就告一段落了，本来想再补充一下基于身份的密码体制的，但自己也没理解透，所以就不误导大家了，这里留两个链接日后看吧-<a href="https://www.zhihu.com/question/26533817/answer/33165735" target="_blank" rel="external">[1]</a>、<a href="http://wenku.baidu.com/link?url=xhCcnLatLhZSMGFLTUHlPUHvLTfYfME9gesW-7VA4CeW0izeCPW5e_qHi8LX9x2mPPX_t_PzlFbyMkGlQDYZyDEY3O6C1yeDpf3t-pocYKG" target="_blank" rel="external">[2]</a></p>
<p>就这样，下面进入消息认证机制，主要是介绍一些杂凑函数。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡背景">0x00 口胡背景</h1><p>Neal Koblitz和Victor Miller在1985年分别提出了椭圆曲线密码体制(ECC)，它是迄今为止被实践证明安全有效的三类公钥密码体制之一。<br>1998年被ISO/IEC定为数字签名标准，]]>
    </summary>
    
      <category term="密码学" scheme="http://kenshichong.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="cryptography" scheme="http://kenshichong.github.io/categories/cryptography/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[密码系列10-数论不白学之ElGamal公钥密码算法]]></title>
    <link href="http://kenshichong.github.io/2016/01/07/%E5%AF%86%E7%A0%81%E7%B3%BB%E5%88%9710-%E6%95%B0%E8%AE%BA%E4%B8%8D%E7%99%BD%E5%AD%A6%E4%B9%8BElGamal%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    <id>http://kenshichong.github.io/2016/01/07/密码系列10-数论不白学之ElGamal公钥密码算法/</id>
    <published>2016-01-07T14:47:11.000Z</published>
    <updated>2016-01-10T15:38:59.595Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>前面我们对公钥密码体制进行了一个总体的介绍，然后对公钥密码的一个典型代表-RSA进行了详细介绍，知道了为什么好多从事密码事业的人并不是计算机相关专业科班出身，而是数学专业科班出身。反正你数学不好，你想在密码上有所造诣，不是说没可能，我只能说难，好吧(语气词)。</p>
<p>RSA的安全性来自于求一对大素数的乘积很容易，但要对这个乘积进行因式分解则非常困难，也就是所谓的大整数分解问题。</p>
<p>而我们今天的主角ElGamal公钥密码算法，它的安全性来源于另一个数学难题-离散对数难题，即已知g为Zp*(乘法群)的生成元(对于乘法群的生成元的概念，给两个链接-<a href="http://www.zhihu.com/question/23353412" target="_blank" rel="external">1</a>、<a href="http://zhidao.baidu.com/link?url=bGc3UiaExw2yYeMHPGjQxOAkk-O6G9BqevgOiStiw1WSWql5l9vVis1iZ_Hd_akv3K7f78L8VcAd9ZDxVc9BYfbsVAPcMhafIlabO_faosK" target="_blank" rel="external">2</a>)，y∈ Zp ，求x使得y=g^x mod p，这个x在现阶段是不可求的，这就是ElGamal公钥密码算法安全性的来源，如果求离散对数问题是容易的，则获得y能够解出x，则这类算法完全破译</p>
<h1 id="0x01_ElGamal算法流程">0x01 ElGamal算法流程</h1><h2 id="1-_密钥产生过程">1. 密钥产生过程</h2><p>首先选择一大素数p, 原根g和小于p的随机数x，计算y≡g^x mod p，以(y, g, p)作为公开密钥，x作为秘密密钥.<br>这里说明一下，g是模p的原根，原根的概念，数论姿势那有讲，再补充一点，原根是乘法群的一个生成元，所以说ElGamal公钥密码算法中生成元一般取原根</p>
<h2 id="2-_加密过程">2. 加密过程</h2><p>设欲加密明文消息为M(如果M长度超过p则进行分组) . 随机选与p-1互素的整数k，1&lt; k&lt;p-1<br>计算密文对: C = {C1,C2}, 发送给接收者.C1≡g^k mod p,   C2≡(y^k) x M mod p.</p>
<h2 id="3-_解密过程">3. 解密过程</h2><p>直接po图：<br><img src="/img/密码系列10-数论不白学之ElGamal公钥密码算法/0.PNG" alt=""></p>
<p>这里对图中说的k 需要永久保密，且不能重复使用进行说明：</p>
<ol>
<li>攻击者若已知k，可以计算y^k,然后用C2/y^k就得到明文；</li>
<li>若是k重复使用，则C2/C2’=M/M’,知道其中的一个明文，另一个可求。</li>
</ol>
<p>下面我们举一个比较贴近现实(就是数字很大)的例子:<br><img src="/img/密码系列10-数论不白学之ElGamal公钥密码算法/1.PNG" alt=""><br><img src="/img/密码系列10-数论不白学之ElGamal公钥密码算法/2.PNG" alt=""><br><img src="/img/密码系列10-数论不白学之ElGamal公钥密码算法/3.PNG" alt=""></p>
<p>这可以算是ElGamal公钥密码算法的具体应用了，下面我们再以一个数字较小的例子来直观的感受下，里面的运算涉及到幂运算，求逆元，这些都是前面介绍过的。</p>
<p><img src="/img/密码系列10-数论不白学之ElGamal公钥密码算法/4.PNG" alt=""><br><img src="/img/密码系列10-数论不白学之ElGamal公钥密码算法/5.PNG" alt=""></p>
<h1 id="0x02_ElGamal与RSA的对比">0x02 ElGamal与RSA的对比</h1><p>到这，ElGamal公钥密码算法就算介绍完了，最后po张ElGamal与RSA的对比图：</p>
<p><img src="/img/密码系列10-数论不白学之ElGamal公钥密码算法/6.PNG" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_口胡">0x00 口胡</h1><p>前面我们对公钥密码体制进行了一个总体的介绍，然后对公钥密码的一个典型代表-RSA进行了详细介绍，知道了为什么好多从事密码事业的人并不是计算机相关专业科班出身，而是数学专业科班出身。反正你数学不好，你想在密码上有所造诣]]>
    </summary>
    
      <category term="密码学" scheme="http://kenshichong.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="cryptography" scheme="http://kenshichong.github.io/categories/cryptography/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[密码系列9-数论不白学之RSA]]></title>
    <link href="http://kenshichong.github.io/2016/01/07/%E5%AF%86%E7%A0%81%E7%B3%BB%E5%88%979-%E6%95%B0%E8%AE%BA%E4%B8%8D%E7%99%BD%E5%AD%A6%E4%B9%8BRSA/"/>
    <id>http://kenshichong.github.io/2016/01/07/密码系列9-数论不白学之RSA/</id>
    <published>2016-01-07T08:12:31.000Z</published>
    <updated>2016-01-07T14:14:46.447Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_RSA算法描述">0x00 RSA算法描述</h1><p>RSA算法是1978年由R.Rivest, A.Shamir和L.Adleman提出的一种用数论构造的、也是迄今为止理论上最为成熟完善的公钥密码体制，该体制已得到广泛的应用。</p>
<h2 id="1-_密钥的产生">1. 密钥的产生</h2><p><img src="/img/密码系列9-数论不白学之RSA/0.PNG" alt=""></p>
<p>让我们结合前面介绍的数论姿势来解释下每一步具体应该如何实现。</p>
<p><strong>1. 选两个保密的大素数p 和q</strong><br>这一步的实现需要用到我们前面讲的素性检测的姿势</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/28.PNG" alt=""></p>
<p>素性检测算法采用Miller-Rabin素性检测算法，这一步我们已经可以实现，看下一步</p>
<p><strong>2. 计算n = p× q,φ( n) = ( p - 1 ) ( q - 1) , 其中φ( n) 是n 的欧拉函数值。</strong></p>
<p>这一步没什么好说的，上一步p,q都产生了，n自然就生成了，欧拉函数值也就产生了。这里由于p和q是素数，所以n的欧拉函数值是(p-1)(q-1)，关于欧拉函数值的具体如何计算，前面也介绍过。看下一步</p>
<p><strong>3. 选一整数e, 满足1 &lt; e&lt; φ( n) , 且gcd(φ( n) , e) = 1</strong></p>
<p>对于整数e的选取，一般取较小的素数，比如3啊，5啊之类的，对于是否满足最大公约数为1的验证，我们前面也介绍了可以用辗转相除法求最大公约数，如果经验证当前选中的e与n的欧拉函数值不互素的话，再换一个e，知道选中合适的e即可，这一步也不难。看下一步</p>
<p><strong>4.计算d, 满足d· e≡1 mod φ( n) , 即d 是e 在模φ( n)下的乘法逆元, 因e 与φ( n)互素, 由模运算可知, 它的乘法逆元一定存在。</strong></p>
<p>对于d的计算，即乘法逆元的计算问题，前面提到过用逆推辗转相除法来实现求逆元。也不难，看下一步</p>
<p><strong>5.以{ e, n} 为公开钥, { d , n}为秘密钥。</strong></p>
<p>这一步更没什么说的了。。。</p>
<hr>
<p>到这，我们已经实现了生成RSA算法的公开钥和秘密钥，接下来就可以用这两个钥匙了。可以看出，有了前面的数论基础，RSA的每一步实现都是挺简单的，接下来，我们看一些RSA其他的东西。</p>
<h2 id="2-_加密">2. 加密</h2><p>加密时首先将明文比特串分组, 使得每个分组对应的十进制数小于n, 即分组长度小于log2 n，因为需要进行模n运算嘛，当然不能超过n了，要不然就会加密不完全，我也不知道该怎么描述，反正就是仔细一想的话，如果超过n的话，超过n的那一部分可以说在一开始就是多余的，模n的话跟直接舍去没什么两样。然后对每个明文分组m, 作加密运算:c≡m^e mod n</p>
<h2 id="3-_解密">3. 解密</h2><p>对密文分组的解密运算为： m≡c^d mod n</p>
<p>我们举个例子来看下RSA的具体运用以及计算过程：</p>
<p><img src="/img/密码系列9-数论不白学之RSA/2.PNG" alt=""></p>
<h1 id="0x01_RSA_算法中解密过程的正确性">0x01 RSA 算法中解密过程的正确性</h1><p>排版麻烦，直接截图了</p>
<p><img src="/img/密码系列9-数论不白学之RSA/1.PNG" alt=""></p>
<h1 id="0x02_RSA算法中的计算问题">0x02 RSA算法中的计算问题</h1><p>通过上面的介绍，我们对于RSA的整体流程已经没有问题了，下面我们来讨论下在RSA中如何优化一些比较复杂的计算步骤。</p>
<h2 id="1-_RSA的加密与解密过程">1. RSA的加密与解密过程</h2><p>RSA 的加密、解密过程都为求一个整数的整数次幂, 再取模。如果按其含义直接计算, 则中间结果非常大, 有可能超出计算机所允许的整数取值范围。如上例中解密运算6677 mod 119 , 先求6677 再取模, 则中间结果就已远远超出了计算机允许的整数取值范围。这时我们就要采取策略了。</p>
<p><strong>策略1 提高指数运算的有效性 </strong><br>例如求x^16 , 直接计算的话需做15 次乘法。然而如果重复对每个部分结果做平方运算即求x, x^2 ,x^4 , x^8 , x^16 则只需4 次乘法。我们这里将指数用二进制形式表示可以提高指数运算的有效性。</p>
<p><img src="/img/密码系列9-数论不白学之RSA/3.PNG" alt=""></p>
<p>将指数运算化为这种形式后，此时并没有什么卵用，别急，要结合策略2</p>
<p><strong> 策略2 模运算的性质 </strong><br>运用模运算性质：( a× b) mod n = [ ( a mod n) × ( b mod n) ] mod n来简化运算。我们运用策略1将指数运算化为上述形式后，结合策略2，那么我们最多只需计算2次幂就可以得到最终结果。举个例子：</p>
<p><img src="/img/密码系列9-数论不白学之RSA/4.PNG" alt=""><br><img src="/img/密码系列9-数论不白学之RSA/5.PNG" alt=""></p>
<p>简化指数运算对应的代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c= <span class="number">0</span> ; d = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> i = k downto <span class="number">0</span> d0 &#123;</span><br><span class="line">c= <span class="number">2</span>× c;</span><br><span class="line">d= ( d× d) mod n;</span><br><span class="line"><span class="keyword">if</span> bi = <span class="number">1</span> then &#123;</span><br><span class="line">c= c+ <span class="number">1</span> ;</span><br><span class="line">d = ( d× a) mod n</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d</span><br></pre></td></tr></table></figure></p>
<p>其中d 是中间结果, d 的终值即为所求结果。c 在这里的作用是表示指数的部分结果, 在这里起到便于理解的目的，其终值即为指数m, c 对计算结果无任何贡献, 算法中完全可将之去掉。</p>
<h2 id="2-_RSA密钥的产生">2. RSA密钥的产生</h2><p>这个问题我们在上面讨论流程的时候已经说过了，下面说的详细点。<br>产生密钥时, 需要考虑两个大素数p、q 的选取, 以及e 的选取和d 的计算。因为n = pq 在体制中是公开的, 因此为了防止敌手通过穷搜索发现p、q, 这两个素数应是在一个足够大的整数集合中选取的大数。如果选取p 和q 为1010 0 左右的大素数, 那么n 的阶为1020 0 , 每个明文分组可以含有664 位( 1020 0 ≈2664 ) , 即83 个8 比特字节, 这比DES 的数据分组(8 个8 比特字节) 大得多, 这时就能看出RSA 算法的优越性了。因此如何有效地寻找大素数是第一个需要解决的问题。寻找大素数时一般是先随机选取一个大的奇数(例如用伪随机数产生器) , 然后用素性检验算法检验这一奇数是否为素数, 如果不是则选取另一大奇数, 重复这一过程, 直到找到素数为止。素性检验算法通常都是概率性的, 但如果算法被多次重复执行, 每次执行时输入不同的参数, 算法的检验结果都认为被检验的数是素数, 那么就可以比较有把握地认为被检验的数是素数。例如Miller-Rabin 算法。可见寻找大素数是一个比较繁琐的工作。然而在RSA 体制中, 只有在产生新密钥时才需执行这一工作。p 和q 决定出后, 下一个需要解决的问题是如何选取满足1 &lt; e&lt; φ( n) 和gcd (φ( n) ,e) = 1 的e, 并计算满足d· e≡1 mod φ( n)的d。这一问题可由推广Euclid 算法完成。</p>
<h1 id="0x03_RSA的安全性">0x03 RSA的安全性</h1><p>RSA 的安全性是基于分解大整数的困难性假定, 之所以为假定是因为至今还未能证明分解大整数就是NP问题(NP问题自行google), 也许有尚未发现的多项式时间分解算法。如果RSA 的模数n 被成功地分解为p×q, 则立即获得φ( n) = ( p - 1) ( q - 1 ) ,从而能够确定e 模φ( n) 的乘法逆元d, 即d≡ e^(-1) mod φ( n) , 因此攻击成功。</p>
<p>随着人类计算能力的不断提高, 原来被认为是不可能分解的大数已被成功分解。例如RSA-129 (即n 为129 位十进制数, 大约428 个比特)已在网络上通过分布式计算历时8 个月于1994 年4 月被成功分解, RSA-130 已于1996 年4 月被成功分解。</p>
<p>对于大整数的威胁除了人类的计算能力外, 还来自分解算法的进一步改进。分解算法过去都采用二次筛法, 如对RSA-129 的分解。而对RSA-130 的分解则采用了一个新算法, 称为推广的数域筛法, 该算法在分解RSA-130 时所做的计算仅比分解RSA-129 多10%。将来也可能还有更好的分解算法, 因此在使用RSA 算法时对其密钥的选取要特别注意其大小。估计在未来一段比较长的时期, 密钥长度介于1024 比特至2048 比特之间的RSA 是安全的。</p>
<p>是否有不通过分解大整数的其他攻击途径? 下面证明由n 直接确定φ( n)等价于对n的分解。</p>
<p><img src="/img/密码系列9-数论不白学之RSA/6.PNG" alt=""></p>
<p>所以，n 直接确定φ( n)等价于对n的分解。但是，从上面的证明过程我们发现了新的问题。为保证算法的安全性, 对p 和q 提出以下要求:</p>
<ol>
<li>| p - q| 要大</li>
</ol>
<p><img src="/img/密码系列9-数论不白学之RSA/7.PNG" alt=""></p>
<ol>
<li>p - 1 和q - 1 都应有大素因子</li>
</ol>
<p><img src="/img/密码系列9-数论不白学之RSA/8.PNG" alt=""><br><img src="/img/密码系列9-数论不白学之RSA/9.PNG" alt=""></p>
<p>上图已经说明了要避免这种重复加密攻击，须使t大，但这跟 p - 1 和q - 1 都应有大素因子有卵关系，别急，下面证明二者的等价性：</p>
<p><img src="/img/密码系列9-数论不白学之RSA/10.PNG" alt=""></p>
<h1 id="0x04_一定条件下对RSA算法的攻击">0x04 一定条件下对RSA算法的攻击</h1><h2 id="1-_共模攻击">1. 共模攻击</h2><p>在实现RSA时，为方便起见，可能给每一用户相同的模数n，虽然加解密密钥不同，然而这样做是不行的。<br>攻击手段：</p>
<p><img src="/img/密码系列9-数论不白学之RSA/11.PNG" alt=""></p>
<h2 id="2-_低指数攻击">2. 低指数攻击</h2><p><img src="/img/密码系列9-数论不白学之RSA/12.PNG" alt=""></p>
<h1 id="0x05_RSA算法的填充">0x05 RSA算法的填充</h1><p>PKCS#1 v2.1或IEEE P1363都推荐使用e=3,因为这样加密速度很</p>
<p>PKCS#1模式中，如果密钥长度为1024位，那么输出的密文块长度为128个字节，输入的明文块长度最大是117个字节，如果输入的明文块小于117位。EM = 0x00 || 0x02 || PS || 0x00 || M<br>PS为随机数保证了同一M不同次加密不一样, PS长度为128- 3 - Len(M)</p>
<p>OS2IP 则是将一八位串转换为一非负整数,它的描述如下(RFC3447):<br>x = x<em>(xLen-1) 256^(xLen-1) + x</em>(xLen-2)256^(xLen-2) + …+ x_1 256 + x_0</p>
<p>RSA就到这。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_RSA算法描述">0x00 RSA算法描述</h1><p>RSA算法是1978年由R.Rivest, A.Shamir和L.Adleman提出的一种用数论构造的、也是迄今为止理论上最为成熟完善的公钥密码体制，该体制已得到广泛的应用。</p>
<h2 id]]>
    </summary>
    
      <category term="密码学" scheme="http://kenshichong.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="cryptography" scheme="http://kenshichong.github.io/categories/cryptography/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[密码系列8-简短过渡之口胡公钥密码体制]]></title>
    <link href="http://kenshichong.github.io/2016/01/06/%E5%AF%86%E7%A0%81%E7%B3%BB%E5%88%978-%E7%AE%80%E7%9F%AD%E8%BF%87%E6%B8%A1%E4%B9%8B%E5%8F%A3%E8%83%A1%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/"/>
    <id>http://kenshichong.github.io/2016/01/06/密码系列8-简短过渡之口胡公钥密码体制/</id>
    <published>2016-01-06T13:35:08.000Z</published>
    <updated>2016-01-07T08:11:18.046Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_公钥密码体制概念">0x00 公钥密码体制概念</h1><p>在公钥密码体制以前的整个密码学史中, 所有的密码算法, 包括原始手工计算的、由机械设备实现的以及由计算机实现的, 都是基于代换和置换这两个基本工具。而公钥密码体制则为密码学的发展提供了新的理论和技术基础, 一方面公钥密码算法的基本工具不再是代换和置换, 而是数学函数;另一方面公钥密码算法是以非对称的形式使用两个密钥, 两个密钥的使用对保密性、密钥分配、认证等都有着深刻的意义。可以说公钥密码体制的出现在密码学史上是迄今为止最大的而且是惟一真正的革命。公钥密码体制的概念是在解决单钥密码体制中最难解决的两个问题时提出的, 这两个问题是密钥分配和数字签字。单钥密码体制在进行密钥分配时, 要求通信双方或者已经有一个共享的密钥, 或者可借助于一个密钥分配中心。对第1 个要求, 常常可用人工方式传送双方最初共享的密钥, 这种方法成本很高, 而且还完全依赖于信使的可靠性。第2 个要求则完全依赖于密钥分配中心的可靠性。第2 个问题数字签字考虑的是如何为数字化的消息或文件提供一种类似于为书面文件手书签字的方法。1976 年W .Diffie 和M .Hellman 对解决上述两个问题有了突破, 从而提出了公钥密码体制。</p>
<h1 id="0x01_公钥密码体制的原理">0x01 公钥密码体制的原理</h1><p>公钥密码算法的最大特点是采用两个相关密钥将加密和解密能力分开, 其中一个密钥是公开的, 称为公开密钥, 简称公开钥, 用于加密; 另一个密钥是为用户专用, 因而是保密的, 称为秘密密钥, 简称秘密钥, 用于解密。因此公钥密码体制也称为双钥密码体制。算法有以下重要特性: 已知密码算法和加密密钥, 求解密密钥在计算上是不可行的。</p>
<p>下图是公钥体制加密的框图</p>
<p><img src="/img/密码系列8-简短过渡之口胡公钥密码体制/0.PNG" alt=""></p>
<p>加密过程有以下几步:</p>
<ol>
<li>要求接收消息的端系统, 产生一对用来加密和解密的密钥, 如图中的接收者B, 产生一对密钥PKB , SKB , 其中PKB 是公开钥, SKB 是秘密钥。</li>
<li>端系统B 将加密密钥( 如图中的PKB ) 予以公开。另一密钥则被保密( 图中的SKB )。</li>
<li>A要想向B发送消息m，则使用B的公开钥加密m，表示为c=EPKB[m],其中c是密文，E是加密算法。<br>4.B收到密文c后，用自己的秘密钥SKB解密，表示为m=DSKB[c]，其中D是解密算法。<br>因为只有B 知道SKB , 所以其他人都无法对c 解密。</li>
</ol>
<p>公钥加密算法不仅能用于加、解密, 还能用于对发方A 发送的消息m 提供认证, 如下图：</p>
<p><img src="/img/密码系列8-简短过渡之口胡公钥密码体制/1.PNG" alt=""></p>
<ol>
<li>用户A用自己的秘密钥SKA对m加密，表示为c=ESKA[m]，将c发往B。</li>
<li>B用A的公开钥PKA对c解密m=DPKA[c]因为从m得到c是经过A的秘密钥SKA加密，只有A才能做到。因此c可当做A对m的数字签字。另一方面，任何人只要得不到A的秘密钥SKA就不能篡改m，所以获得了对消息来源和消息完整性的认证。</li>
</ol>
<p>在实际应用中, 特别是用户数目很多时, 以上认证方法需要很大的存储空间, 因为每个文件都必须以明文形式存储以方便实际使用, 同时还必须存储每个文件被加密后的密文形式即数字签字, 以便在有争议时用来认证文件的来源和内容。改进的方法是减小文件的数字签字的大小, 即先将文件经过一个函数压缩成长度较小的比特串, 得到的比特串称为认证符。认证符具有这样一个性质: 如果保持认证符的值不变而修改文件这在计算上是不可行的。用发送者的秘密钥对认证符加密, 加密后的结果为原文件的数字签字。</p>
<p>就是现在说的数字签名技术，数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。数字签名是个加密的过程，数字签名验证是个解密的过程。这样说应该很清楚了</p>
<p>口胡一下，就是比如A给B一份文件，这个文件B拿到的就是这个文件的明文，而非文件的加密，现在的问题是B并不知道这个文件是不是A给他的，也可能有人假传圣旨，这时B不必慌张，因为随着该文件一块到的还有该文件的数字签名，数字签名的产生是该文件经过一个hash函数产生一个能够代表该文件的文件摘要，然后A用它的私钥对该摘要进行加密后生成的，相当于A用自己的私钥在这份文件上盖了个戳，说这是我A发的，那么B如何验证呢？B会用A公布的公钥对这个数字签名进行解密，然后B会用同样的hash对该文件生成文件摘要，然后比对该文件摘要与解密的文件摘要是否一致，一致则说明该文件确实来源于A，这个过程其实也保证了文件数据的完整性，因为一旦有人篡改文件，那么该文件的文件摘要就会改变，那么在B处生成的文件摘要就无法与解密数字签名后的文件摘要进行匹配，这时B就会知道该文件出了问题，然后采取相应的措施。</p>
<p>以上认证过程中, 由于消息是由用户自己的秘密钥加密的, 所以消息不能被他人篡改, 但却能被他人窃听。这是因为任何人都能用用户的公开钥对消息解密得到明文信息。为了同时提供认证功能和保密性, 可使用双重加、解密。如下图所示：</p>
<p><img src="/img/密码系列8-简短过渡之口胡公钥密码体制/2.PNG" alt=""></p>
<p>发方首先用自己的秘密钥SKA对消息m加密，用于提供数字签字。再用收方的公开钥PKB第2次加密，表示为c=EPKB[ESKA[m]]<br>解密过程为m=DPKA[DSKB[c]]，即收方先用自己的秘密钥,再用发方的公开钥对收到的密文两次解密。</p>
<h1 id="0x02_公钥密码算法应满足的要求">0x02 公钥密码算法应满足的要求</h1><ol>
<li>接收方B产生密钥对（公开钥PKB和秘密钥SKB）在计算上是容易的。</li>
<li>发方A用收方的公开钥对消息m加密以产生密文c，即c=EPKB[m]在计算上是容易的。</li>
<li>收方B用自己的秘密钥对c解密，即m=DSKB[c]在计算上是容易的。</li>
<li>敌手由B的公开钥PKB求秘密钥SKB在计算上是不可行的。</li>
<li>敌手由密文c和B的公开钥PKB恢复明文m在计算上是不可行的。</li>
<li>加、解密次序可换，即EPKB[DSKB(m)]=DSKB[EPKB(m)]<br>(其中最后一条虽然非常有用，但不是对所有的算法都作要求。)</li>
</ol>
<p>以上要求的本质之处在于要求一个陷门单向函数。单向函数是两个集合X、Y 之间的一个映射, 使得Y 中每一元素y 都有惟一的一个原像x∈ X, 且由x 易于计算它的像y ,由y 计算它的原像x 是不可行的。这里所说的易于计算是指函数值能在其输入长度的多项式时间内求出, 即如果输入长n 比特, 则求函数值的计算时间是na 的某个倍数, 其中a 是一固定的常数。这时称求函数值的算法属于多项式类P , 否则就是不可行的。例如,函数的输入是n 比特, 如果求函数值所用的时间是2n 的某个倍数, 则认为求函数值是不可行的。注意这里的易于计算和不可行两个概念与计算复杂性理论中复杂度的概念极为相似, 然而又存在着本质的区别。在复杂性理论中, 算法的复杂度是以算法在最坏情况或平均情况时的复杂度来度量的。而在此所说的两个概念是指算法在几乎所有情况下的情形。称一个函数是陷门单向函数, 是指该函数是易于计算的, 但求它的逆是不可行的, 除非再已知某些附加信息。当附加信息给定后, 求逆可在多项式时间完成。总结为: 陷门单向函数是一族可逆函数f k , 满足：</p>
<ol>
<li>k和X已知时，Y=fk(X)易于计算。</li>
<li>k和Y已知时，X=f-1k(Y)易于计算。</li>
<li>Y已知但k未知，X=f-1k(Y)计算上是不可行的。</li>
</ol>
<p>因此, 研究公钥密码算法就是要找出合适的陷门单向函数。</p>
<h1 id="0x03_对公钥密码体制的攻击">0x03 对公钥密码体制的攻击</h1><p>和单钥密码体制一样, 如果密钥太短, 公钥密码体制也易受到穷搜索攻击。因此密钥必须足够长才能抗击穷搜索攻击。然而又由于公钥密码体制所使用的可逆函数的计算复杂性与密钥长度常常不是呈线性关系, 而是增大得更快。所以密钥长度太大又会使得加解密运算太慢而不实用。因此公钥密码体制目前主要用于密钥管理和数字签字。</p>
<p>对公钥密码算法的第2 种攻击法是寻找从公开钥计算秘密钥的方法。目前为止, 对常用公钥算法还都未能够证明这种攻击是不可行的。</p>
<p>还有一种仅适用于对公钥密码算法的攻击法, 称为可能字攻击。例如对56 比特的DES 密钥用公钥密码算法加密后发送, 敌手用算法的公开钥对所有可能的密钥加密后与截获的密文相比较。如果一样, 则相应的明文即DES 密钥就被找出。因此不管公钥算法的密钥多长, 这种攻击的本质是对56 比特DES 密钥的穷搜索攻击。抵抗方法是在欲发送的明文消息后添加一些随机比特。</p>
<p>由于是简短的过渡blog，所以就口胡到这。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_公钥密码体制概念">0x00 公钥密码体制概念</h1><p>在公钥密码体制以前的整个密码学史中, 所有的密码算法, 包括原始手工计算的、由机械设备实现的以及由计算机实现的, 都是基于代换和置换这两个基本工具。而公钥密码体制则为密码学的发展提供了新的理论]]>
    </summary>
    
      <category term="密码学" scheme="http://kenshichong.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="cryptography" scheme="http://kenshichong.github.io/categories/cryptography/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[密码系列7-公钥密码之从RSA看数论]]></title>
    <link href="http://kenshichong.github.io/2016/01/04/%E5%AF%86%E7%A0%81%E7%B3%BB%E5%88%977-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%B9%8B%E4%BB%8ERSA%E7%9C%8B%E6%95%B0%E8%AE%BA/"/>
    <id>http://kenshichong.github.io/2016/01/04/密码系列7-公钥密码之从RSA看数论/</id>
    <published>2016-01-04T08:53:45.000Z</published>
    <updated>2016-01-10T15:18:31.221Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_背景介绍">0x00 背景介绍</h1><p>本篇主要是由RSA算法的流程引入公钥密码体制所需的数论姿势，也就是说，没错，会让你脑袋疼的东西，反正我是脑袋疼。。。</p>
<h1 id="0x01_RSA流程">0x01 RSA流程</h1><p><img src="/img/密码系列7-公钥密码之从RSA看数论/0.PNG" alt=""></p>
<p>没错，非常简洁的一个算法，流程什么的很容易懂，但是如果细究其中的每一步的细节，那么结果就是-脑子疼。但是，作为共产主义接班人，我们要迎难而上，下面就让我们由简到难来看下其中所涉及到的数论姿势</p>
<h1 id="0x02_各种脑瓜疼的数论姿势">0x02 各种脑瓜疼的数论姿势</h1><h2 id="数论姿势1-如何求最大公约数(公因子)">数论姿势1-如何求最大公约数(公因子)</h2><ol>
<li>整除：设a, b为整数,  b ≠ 0,如果存在整数c, 使得a=bc,  则称b整除a(记为b | a), 否则称b不整除a</li>
<li>最大公约数：若d | a1，d | a2，则称d是a1，a2的一个公因数，其中最大的称为最大公因数，记为(a1，a2)。若(a1，a2)=1，则称a1，a2互质(素)，其他公因子一定是最大公因子的因子(可以用反证法证得，若不是，则二者互质，则二者相乘可以得到更大的公因子，矛盾)</li>
<li>最大公约数的概念不仅仅局限于两个数，最大公约数概念扩展：</li>
</ol>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/1.PNG" alt=""></p>
<ol>
<li>两个数的最大公约数求法：最大公约数必为正整数，且a=bq+r，b≠0=&gt;（a，b)=(b，r)，没错，就是辗转相除法了，通过辗转相除，我们可以很容易快速的求出两个数的最大公约数</li>
<li>三个及三个以上数的最大公约数：需要的定理：</li>
</ol>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/2.PNG" alt=""></p>
<p>下面强行用大白话解释该定理的证明，首先，一方面，因为d|a1，d|a2···d|an-1，还有由(a1，a2···an-1)=dn-1可知前n-1个数的最大公约数是dn-1，同时前n-1个数又可以同时整除d，则由最大公约数的定义(公约数中最大的那个)可知，d&lt;=dn-1，且d|dn-1，而(dn-1，an)=dn，说明dn-1，an的最大公约数是dn，而别忘了d|dn-1且d|an，说明d是dn-1和an的一个公因子，则由其他公因子一定是最大公因子的因子的性质可知，d&lt;=dn这样，对于证明中的一方面，我们就说清了。<br>再来说另一方面，对于(dn-1，an)=dn=&gt;dn|an，dn|dn-1，这没什么好说的，下面的一个推出可以这样理解，dn-1是前n-1个数的最大公约数，说明dn-1是可以被前n-1个数整除的，而dn又是dn-1的一个因子，所以前n-1个数当然也可以整除dn了，这样就推出了前n个数都可以整除dn了，而前n个数的最大公约数是d，所以dn&lt;=d，这样把另一方面的证明也解释通了，一方面结合另一方面，该定理就得到了证明。</p>
<p>这个定理直接为我们求三个及三个以上数的最大公约数提供了依据，通过计算机，我们可以使用一个递归来达到实现求三个及三个以上数的最大公约数的目的。</p>
<ol>
<li>关于最大公约数的一些性质：</li>
</ol>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/3.PNG" alt=""></p>
<h2 id="数论姿势2-最小公倍数">数论姿势2-最小公倍数</h2><p>整数a1, a2, ···, ak的公共倍数称为a1, a2, ···, ak的公倍数。a1, a2, ····, ak的正公倍数中的最小的一个叫做a1, a2, ···, ak的最小公倍数，记为[a1, a2, ···, ak]。<br>一些最小公倍数的基本性质：</p>
<ol>
<li>[a, 1] = |a|，[a, a] = |a|；</li>
<li>[a, b] = [b, a]；</li>
<li>[a1, a2, ···, ak] = [|a1|, |a2| ···, |ak|]；</li>
<li>若a | b，则[a, b] = |b|。</li>
<li><img src="/img/密码系列7-公钥密码之从RSA看数论/4.PNG" alt=""></li>
</ol>
<h2 id="数论姿势3-整数模运算和同余概念">数论姿势3-整数模运算和同余概念</h2><p><img src="/img/密码系列7-公钥密码之从RSA看数论/5.PNG" alt=""></p>
<p>注意同余的符号，同余的概念非常重要，下面来看关于同余的性质：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/6.PNG" alt=""></p>
<ol>
<li>模同余逆元：</li>
</ol>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/7.PNG" alt=""></p>
<p>那么如何求模同余逆元呢？需要以下理论技巧：1.我们前面提到的辗转相除法：<img src="/img/密码系列7-公钥密码之从RSA看数论/8.PNG" alt=""><br>2.最大公约数的线性表示：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/9.PNG" alt=""></p>
<p>解锁了这两个姿势，我们就可以求出模同余逆元了：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/10.PNG" alt=""></p>
<h2 id="数论姿势4-欧拉的故事">数论姿势4-欧拉的故事</h2><p>不得不说，有点佩服这个数学家，虽然他使得我们的学生生活过的并不轻松，但不得不承认他是天才，称之为艺术家不为过。失明过后各种心算，没谁了，我只想说我服。。。<br><strong>欧拉定理</strong><br><img src="/img/密码系列7-公钥密码之从RSA看数论/11.PNG" alt=""><br>利用欧拉定理解题：<br>今天星期三， 313^159天后是星期几?<br>好久没做数学题，所以当时做这个题时是拒绝的，这个题会用到上面的很多同余运算的性质，所以还是有必要做下的。解题过程为：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/12.PNG" alt=""></p>
<p>让我来解释一下，要想求星期几，由于这个数太大，所以我们要尽量缩小它，当然mod7是很好的选择，因为减去7的倍数会在数字缩小的前提下不影响我们判断是星期几。(7k+5)的159次方展开之后，除了5的159次方外，其余项都是带7的，所以可以不用顾忌的直接弃掉，也就是说原来的数与5的159次方是模7同余的，接着使用欧拉定理对5的159次方进行缩小，由于5和7是互质的，所以5的6次方是与1模7同余的，还记得同余运算的性质吗？a与c模m同余，b与d模m同余，则ab与cd模m同余，运用这条性质，可得5的26 x 6次方与1模7也是同余的，而5的3次方是与5的3次方模7同余的，再次运用性质，可得5的159次方是与5的3次方模7同余的，而5的3次方就很容易计算了，他与6模7同余，这样就算出了最后答案。</p>
<p>对于m的欧拉函数的求法：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/13.PNG" alt=""></p>
<p>再介绍一条重要的相似的定理，可以说是欧拉定理的推论：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/14.PNG" alt=""></p>
<h2 id="数论姿势5-同余方程组">数论姿势5-同余方程组</h2><p><img src="/img/密码系列7-公钥密码之从RSA看数论/15.PNG" alt=""><br><strong>解一次同余方程组之孙子定理</strong><br><img src="/img/密码系列7-公钥密码之从RSA看数论/16.PNG" alt=""></p>
<p>举个例子：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/17.PNG" alt=""></p>
<h2 id="数论姿势6-二次剩余">数论姿势6-二次剩余</h2><p><img src="/img/密码系列7-公钥密码之从RSA看数论/18.PNG" alt=""></p>
<p>我们先来讨论下二次剩余，大部分内容参考了blog-<a href="http://blog.sina.com.cn/s/blog_a661ecd50101ayas.html" target="_blank" rel="external">数论学习笔记（5）：二次剩余</a>，我这里会对这篇blog里面的内容写一些我自己的理解。</p>
<p>对于二次剩余方程，其中 a 为整数， p 为奇素数， x 为未知整数。当然，我们不妨限定 a,x 均在 0,1,2,3,…,p-1 内。不过，为了叙述方便我们又经常把 0 去掉（当 a=0 时显然有唯一解 x=0 ）。这里将a，x限定在0,1,2,3,…,p-1 内，按我的理解，因为是模p运算，所以说大于p的所有数经过模p运算后得到的都是小于p的数字，所以因为模p运算，所以我们只需要讨论小于p的数字就ok了，就是说任何大于p的数字都可以在小于p的这个集合中找到等价的数字。</p>
<p>因为我们的最终目的是在小于p的这个数字集合中找到所有的二次剩余嘛，那么，现在我们就很自然的想到了一个问题，对于哪些 a 方程有解？如果有的话有几个解？</p>
<p>我们先给出结论：使方程有解的 a 的取值恰好是 (p-1)/2 个，恰好是全部取值个数的一半。若方程有解，则恰好有两个解，且这两个解的和为p 。</p>
<p>下面证明他。我们考虑 1,2,3,…,p-1 这些数的平方。我们关心的是这些平方有没有重复（模 p 同余）的。这里重复可以这样理解，还是刚才说到的模p运算的等价问题，对于x而言，如果两个不同的x，x的平方模p得到相同的余数，说明二者只需要保留一个即可，因为对于这两个不同的x，他们所对应的二次剩余a(这里a其实就是x平方模p的余数)其实是相同的(还想不懂的话，考虑同余运算的定义，即p整除x平方减a)。假设这里面有两个不相同的平方 u^2,v^2 模 p 同余(先假设存在重复)，则有：p | (u^2-v^2)，即p | ((u+v)(u-v))，这里的意思就是素数p整除两个整数乘积，那么p必然整除其中一个数，这是毋庸置疑的。我们考虑u-v，由于 u-v 不可能是 p 的倍数（因为u，v都小于p嘛，否则有 u=v ），则有 u+v 是 p 的倍数，也就是说 u+v=p 。到这里，我们就已经可以看出来了，对于满足条件u+v=p的u和v，他们的平方是重复的，即模p同余的。</p>
<p>我们回过来看，因为我们考虑的集合是[1,p-1]，那么1,2,3,…,p-1 这些数的平方必然可以两两配对(配对的条件是两者之和为p)，每对都模 p 同余，除此之外不在同一对的两个数模 p 不同余。这样，实质不同的平方数只有 (p-1)/2 个，正好可以从中间将他们劈开，[1，(p-1)/2]已经可以代表[(p-1)/2，p-1]这个集合了，因为他们所对应的二次剩余a是一样的，也就是说，[1，(p-1)/2]这个集合中的每一个数对于我们研究二次剩余才是有效的，我们将[1，(p-1)/2]这个集合称为二次剩余问题中p的一个简化系，它们对应着使方程有解的 a 的 (p-1)/2 个取值，而且每个使方程有解的 a 的取值都对应着两个平方数。这就证完了。我们把这 (p-1)/2 个取值称作模 p 的二次剩余，另外 (p-1)/2 个使方程无解的 a 称作模 p 的二次非剩余。另外规定如果 a 是模 p 的二次剩余/二次非剩余，那么与 a 模 p 同余的数也是模 p 的二次剩余/二次非剩余(可以看出，模p的二次剩余其实是有无穷无尽的，这里我们为了讨论问题的方便，将a限定在[1，p-1]这个集合范围内，根据前面的讨论，我们知道这样限定并不会丢失一般性，[1，p-1]这个集合足以涵盖所有的情况)。对于 p 的倍数，规定它既不是模 p 的二次剩余，也不是模 p 的二次非剩余。</p>
<p>这里还要强调一点，就是a是与x^2相对应的，a在[1,p-1]中的分布是不均匀的。所以x的取值范围是[1，(p-1)/2]，而a的取值范围是[1，p]，我们并不能将这个集合像x一样做等分。</p>
<p>有了上面的姿势，我们对于一个奇素数(素数除2外都是奇数)p的二次剩余就有了一套体系的求法。首先求出x的取值范围[1,(p-1)/2]，我们知道这里面的每一个数都对应着一个不同的二次剩余数a，然后对每一个x做平方运算后再模p后就得到了该x对应的二次剩余数a(因为经过了模p运算，所以a定&lt;p)，求完每一个x对应的二次剩余a后，共(p-1)/2个a，但a在[1,p-1]中的分布是不均匀的，剩下的就是二次非剩余了。给出结论：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/19.PNG" alt=""></p>
<p>对于这个结论，需要补充一点，根据上面的结论求出每个的二次剩余可能会大于p，这时别忘了通过模p运算找到这个二次剩余在[1,p-1]这个集合中等价的那个二次剩余。</p>
<p>说到这，我们已经可以求任意一个奇素数的二次剩余了，而且编程也是易于实现的。但是对于奇素数p，当我们随意给定一个a∈[1,p-1]时，我们如何判断这个a是不是该p的二次剩余呢？难道要把所有的二次剩余都求出来后，然后看给定的a是否属于这个集合吗？虽然可以实现，但这样未免效率太低了。艺术家欧拉给出了他的判别条件：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/20.PNG" alt=""></p>
<p>对于这个定理，我不做证明，因为我不会证明，但是它很好用就是了。这个定理也给出了我们求二次剩余和非二次剩余的另一种方法，即对于[1,p-1]，从1开始考虑，逐个判断[1,p-1]中的数是否满足二次剩余判断条件，这样也可以把所有的二次剩余找出来。</p>
<h2 id="数论姿势7-素性测试">数论姿势7-素性测试</h2><p>RSA算法中有生成大素数的需要，那么如何产生一个大素数还得保证该大素数的随机性？我们的思路是随机产生一个大正整数，判断其是不是素数，如果是即为需要的大素数，否则重新产生素数。那么这个随机产生的大正整数是素数的概率是多大呢？如果太小的话，那么这种思路就是不值得的，好在这个概率还可以。数论中有著名的素数定理: 不超过x的素数的个数大约为x/lnx。举个例子：任选一个512位的随机正整数p, 它是素数的概率大约为1/lnp ≈ 1/177, 即平均177个具有适当规模的随机正整数p中将有一个素数。从概率学加计算机的角度来看，这个思路是可取的。那么问题就变成了如何判定这个大正整数是不是素数了，我们称之为素性检测。素性检测可以分为两大类：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/21.PNG" alt=""></p>
<p>确定性算法：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/22.PNG" alt=""></p>
<p>然而没什么鸟用，n较小时还可以用用，但当n为大素数时(几百位)，这两个确定性检测算法就显得尤为笨重且对于计算机来说，计算量有点接受不了，所以抛弃这两个确定性算法，还有个AKS算法，也是确定性算法，是印度人想出来的算法，由于不成熟，所以也没什卵用。让我们来看看有什么好用的概率性算法：首先是费马<br><img src="/img/密码系列7-公钥密码之从RSA看数论/23.PNG" alt=""><br>根据上图的理论，费马提出了他的素性测试法：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/24.PNG" alt=""></p>
<p>然后是Lehmann，不知道这哥们名字怎么读。。。他在费马素性检测算法的基础上做了改进，二者的核心思想都是一样的：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/25.PNG" alt=""></p>
<p>然而，存在一类极其罕见的合数，称为Carmichael，针对所有与N互素的a，N将通过费马测试和Lehmann测试，所以这两种概率性算法我们也不用。</p>
<p>现阶段常用的素性检测算法是Miller-Rabin概率型素性测试算法，对这个定理我也不会证明，并不想证明，会用就行：Miller-Rabin素性检测的理论依据：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/26.PNG" alt=""></p>
<p>对于给定要测试的数n，可以求出该n对应的s和m的值，由此可得Miller-Rabin素性检测算法：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/27.PNG" alt=""></p>
<p>有了较为可靠的素性检测算法后，我们上面的思路就易于实现了，产生素数的步骤可为：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/28.PNG" alt=""></p>
<h2 id="数论姿势8-整数的阶">数论姿势8-整数的阶</h2><p><img src="/img/密码系列7-公钥密码之从RSA看数论/29.PNG" alt=""></p>
<p>这里说明为什么整数的阶一定存在，由条件可知(a，m)=1，想到了什么？没错，就是欧拉定理，描述为a的m的欧拉数次方与1是模m同余的，也就是说，l是一定存在的，至于l是不是m的欧拉数，这个就不知道了，反正一定存在，意思就是l是在不行还可以取m的欧拉数嘛。</p>
<p>关于整数的阶的性质：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/30.PNG" alt=""></p>
<p>第一条性质可以为我们计算整数的阶的运算带来简化，第一条性质说明整数的阶必然是欧拉数的一个公因子，所以我们只需要对欧拉数的公因子进行验证即可，举个例子：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/31.PNG" alt=""></p>
<p>第二第三条性质同样可以简化运算，例子说话：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/32.PNG" alt=""></p>
<p>整数的阶的另外两个重要性质：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/45.PNG" alt=""></p>
<p>这个性质其实是对上面的第三条性质的扩充，我们暂且称它为第四条性质，是一个扩展，意思就是，当我们计算a相对于一个较大的模数m的整数阶时，我们可以对m进行质因数分解，然后分别求较小的因数的阶，最后求这些阶的最小公倍数即可得到原来的那个较大的数的整数阶，这个性质运用的前提是对m进行标准分解，什么是标准分解呢，就是分解成由最简单的质因数连乘的形式，大家小学时应该都学过，反正我小学学过。举个例子：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/33.PNG" alt=""></p>
<p>可以看出运用以上性质简化了运算。在运用这个性质时，还有一点需要注意，那就是对于这个式子：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/37.PNG" alt=""></p>
<p>这个性质不可以被重用，什么意思呢，假设m被分解成有一个因式是2^3(即pi=2，ji=3)，则对于<img src="/img/密码系列7-公钥密码之从RSA看数论/37.PNG" alt="">这个式子的计算，不能把2^3拆成2x2x2，然后分别计算a模2的整数阶，最后再求这3个整数阶的最小公倍数，这样得到的结果并不是a模2^3的整数阶，这样做是不对的，至于如何处理这种形式，就需要下面即将讲到的性质。还有个性质，我们暂且称为第5条性质：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/34.PNG" alt=""><br><img src="/img/密码系列7-公钥密码之从RSA看数论/35.PNG" alt=""></p>
<p>这个性质其实是对上面性质的一个补充，上面也说到了，就是当我们面临标准分解中有次幂这种因子时，应该怎么求，就是用上面的性质求。</p>
<p>对于上面性质的白话解释，先以5^3(p=5,j=3)的情况来说明，这里p=5≠2，那么先计算f2，f2就是a模5^2的整数阶，然后根据性质中说的a的f2次方-1可以整除p^i，而不能整除p^i+1，找到这个临界的i，即可使用这个性质，看j值所属的范围即可得到fj，再啰嗦一下2^3(p=2,j=3)的情况，此时看a的值，然后得到相应的r值，再根据r和j值得到fj。</p>
<p>这样我们在面临要求a模一个较大的m的整数阶时，我们就有了相应的化简方法，实际上就是把m进行标准分解，然后看有没有标准分解中有没有带幂的因子，对于带幂的因子，采用第5条性质先转化为不带幂的，然后根据前面说的前三条性质简化求出不带幂的，然后根据第5条性质就可以得到该带幂因子的整数阶，不带幂的因子用刚开始说的前三条性质简化求出整数阶，这样每一个因子的整数阶就都求出来了，最后再根据第四条性质得出最后的整数阶是标准分解的各因子整数阶的最小公倍数，就是这样。举个例子：</p>
<p><img src="/img/密码系列7-公钥密码之从RSA看数论/38.PNG" alt=""></p>
<h2 id="数论姿势9-原根">数论姿势9-原根</h2><p>原根的定义：<img src="/img/密码系列7-公钥密码之从RSA看数论/39.PNG" alt=""><br>另一个等价的定义：假设一个数g对于P来说是原根，那么g^i mod P的结果两两不同,且有 1&lt;g&lt;P, 1&lt;i&lt;P,那么g可以称为是P的一个原根。简单来说，g^i mod p ≠ g^j mod p （p为素数）其中i≠j且i, j介於1至(p-1)之间则g为p的原根。简单的来说，如果g是P的原根，那么g的（1…P-1）次幂mod P的结果一定互不相同。</p>
<p>这样对于原根的定义就有两个了，一是g模p的整数阶等于p的欧拉函数时，g称为p的一个原根；另一个是g的（1…P-1）次幂mod P的结果一定互不相同时，g称为p的一个原根。为什么说这两个是等价定义呢，让我来解释一下，两者是可以等价互导的，也就是说g模p的整数阶等于p的欧拉函数时，g的（1…P-1）次幂mod P的结果一定互不相同，反过来亦成立。这里只说明由第二个定义导出第一个定义，至于反过来导，看我导完这个应该不是问题，留给大家自己导着玩。g的（1…P-1）次幂mod P的结果互不相同时，g模p的整数阶一定等于p的欧拉函数。为什么这句话是对的呢？用反证法来证，假设存在两个数a∈[1,p-1],b∈[1,p-1]，且不妨设a&gt;b满足(g^a)modP=(g^b)modP,即g^≡(g^b)modp。这说明什么呢？因为没有同余等式两边同除以一个数同余等式依然成立的性质，事实上是我不知道存不存在，只有乘法，没关系，我们回归同余运算最基本的定义，由g^a≡(g^b)modp这个式子可以得到g^a-g^b=p x k(k为整数)，设g^a=p x m+t,g^b=p x n+t,显然t&lt;p,则这个式子可以变形为g^b(g^(a-b)-1)=p x (m-n),进一步变形为(p x n+t)(g^(a-b)-1)=p x (m-n)，再变p x (n x g^(a-b)-n)+t x (g^(a-b)-1)=p x (m-n),再来t x (g^(a-b)-1)=p x (m-n-n x g^(a-b)+n)=p x (m-n x g^(a-b)),即t x (g^(a-b)-1)=p x (m-n x g^(a-b))，到这就差不多了，由于t&lt;p,g^(a-b)-1必存在因子p，所以g^(a-b)-1=p x l(l为整数),即g^(a-b)与1模p同余，这与原根的定义矛盾，即如果存在两个数a∈[1,p-1],b∈[1,p-1]，g的a，b次幂mod P的结果相同时，通过上面的证明可以知道由于a-b&lt;p的欧拉函数，所以此时g模p的整数的阶就变成了a-b，而非原根定义要求的必须是p的欧拉函数值，所以从原根的定义出发，g的（1…P-1）次幂mod P的结果一定互不相同时，g模p的整数阶才等于p的欧拉函数，这样的g才能被称为原根，就是说如果g的（1…P-1）次幂mod P的结果存在两个相同的值的时候，g是不能被称为原根的。好像说了半天，越说越糊涂，总之就是想证明一下，为什么g模p的整数阶等于p的欧拉函数时一定会满足g的（1…P-1）次幂mod P的结果一定互不相同，查了好多资料都没说，只能自己硬生生证明了，就这样。</p>
<p>现在我们已经对原根的概念有了个大体的认识，知道了要想成为原根应该具备什么资格。</p>
<p>原根的性质：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/40.PNG" alt=""></p>
<p>举个例子：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/41.PNG" alt=""></p>
<p>这是直接对一个奇素数求原根，当我们知道一个奇素数的原根时，如果要求这个奇素数的幂的原根，这时需要用到下面一条性质：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/42.PNG" alt=""></p>
<p>举个例子：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/43.PNG" alt=""></p>
<p>在密码应用中，通常需要产生一个很大的素数的原根，根据上面的第一个性质我们可以知道，当p的欧拉数只能分解成两个素数乘积的时候找原根的速度会很快，所以当我们可以故意产生一个p，使得他的欧拉数只能分解成两个素数乘积的形式，一般采用的形式是p=q x 2+1<br>下面给出具体的算法：<br><img src="/img/密码系列7-公钥密码之从RSA看数论/44.PNG" alt=""></p>
<hr>
<p>数论的姿势就先科普到这里，下面进入真正的公钥密码算法。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_背景介绍">0x00 背景介绍</h1><p>本篇主要是由RSA算法的流程引入公钥密码体制所需的数论姿势，也就是说，没错，会让你脑袋疼的东西，反正我是脑袋疼。。。</p>
<h1 id="0x01_RSA流程">0x01 RSA流程</h1><p><im]]>
    </summary>
    
      <category term="密码学" scheme="http://kenshichong.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="cryptography" scheme="http://kenshichong.github.io/categories/cryptography/"/>
    
  </entry>
  
</feed>
